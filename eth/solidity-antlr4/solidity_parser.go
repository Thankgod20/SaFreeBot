// Code generated from ../solidity-antlr4/Solidity.g4 by ANTLR 4.12.0. DO NOT EDIT.

package solidityparser // Solidity
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type SolidityParser struct {
	*antlr.BaseParser
}

var solidityParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func solidityParserInit() {
	staticData := &solidityParserStaticData
	staticData.literalNames = []string{
		"", "'pragma'", "';'", "'*'", "'||'", "'^'", "'~'", "'>='", "'>'", "'<'",
		"'<='", "'='", "'as'", "'import'", "'from'", "'{'", "','", "'}'", "'abstract'",
		"'contract'", "'interface'", "'library'", "'is'", "'('", "')'", "'error'",
		"'using'", "'for'", "'|'", "'&'", "'+'", "'-'", "'/'", "'%'", "'=='",
		"'!='", "'struct'", "'modifier'", "'function'", "'returns'", "'event'",
		"'enum'", "'['", "']'", "'address'", "'.'", "'mapping'", "'=>'", "'memory'",
		"'storage'", "'calldata'", "'if'", "'else'", "'try'", "'catch'", "'while'",
		"'unchecked'", "'assembly'", "'do'", "'return'", "'throw'", "'emit'",
		"'revert'", "'var'", "'bool'", "'string'", "'byte'", "'++'", "'--'",
		"'new'", "':'", "'delete'", "'!'", "'**'", "'<<'", "'>>'", "'&&'", "'?'",
		"'|='", "'^='", "'&='", "'<<='", "'>>='", "'+='", "'-='", "'*='", "'/='",
		"'%='", "'let'", "':='", "'=:'", "'switch'", "'case'", "'default'",
		"'->'", "'callback'", "'override'", "", "", "", "", "", "", "", "",
		"", "", "", "'anonymous'", "'break'", "'constant'", "'immutable'", "'continue'",
		"'leave'", "'external'", "'indexed'", "'internal'", "'payable'", "'private'",
		"'public'", "'virtual'", "'pure'", "'type'", "'view'", "'global'", "'constructor'",
		"'fallback'", "'receive'",
	}
	staticData.symbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "Int", "Uint", "Byte",
		"Fixed", "Ufixed", "BooleanLiteral", "DecimalNumber", "HexNumber", "NumberUnit",
		"HexLiteralFragment", "ReservedKeyword", "AnonymousKeyword", "BreakKeyword",
		"ConstantKeyword", "ImmutableKeyword", "ContinueKeyword", "LeaveKeyword",
		"ExternalKeyword", "IndexedKeyword", "InternalKeyword", "PayableKeyword",
		"PrivateKeyword", "PublicKeyword", "VirtualKeyword", "PureKeyword",
		"TypeKeyword", "ViewKeyword", "GlobalKeyword", "ConstructorKeyword",
		"FallbackKeyword", "ReceiveKeyword", "Identifier", "StringLiteralFragment",
		"VersionLiteral", "WS", "COMMENT", "LINE_COMMENT",
	}
	staticData.ruleNames = []string{
		"sourceUnit", "pragmaDirective", "pragmaName", "pragmaValue", "version",
		"versionOperator", "versionConstraint", "importDeclaration", "importDirective",
		"importPath", "contractDefinition", "inheritanceSpecifier", "contractPart",
		"stateVariableDeclaration", "fileLevelConstant", "customErrorDefinition",
		"typeDefinition", "usingForDeclaration", "usingForObject", "usingForObjectDirective",
		"userDefinableOperators", "structDefinition", "modifierDefinition",
		"modifierInvocation", "functionDefinition", "functionDescriptor", "returnParameters",
		"modifierList", "eventDefinition", "enumValue", "enumDefinition", "parameterList",
		"parameter", "eventParameterList", "eventParameter", "functionTypeParameterList",
		"functionTypeParameter", "variableDeclaration", "typeName", "userDefinedTypeName",
		"mappingKey", "mapping", "mappingKeyName", "mappingValueName", "functionTypeName",
		"storageLocation", "stateMutability", "block", "statement", "expressionStatement",
		"ifStatement", "tryStatement", "catchClause", "whileStatement", "simpleStatement",
		"uncheckedStatement", "forStatement", "inlineAssemblyStatement", "inlineAssemblyStatementFlag",
		"doWhileStatement", "continueStatement", "breakStatement", "returnStatement",
		"throwStatement", "emitStatement", "revertStatement", "variableDeclarationStatement",
		"variableDeclarationList", "identifierList", "elementaryTypeName", "expression",
		"primaryExpression", "expressionList", "nameValueList", "nameValue",
		"functionCallArguments", "functionCall", "assemblyBlock", "assemblyItem",
		"assemblyExpression", "assemblyMember", "assemblyCall", "assemblyLocalDefinition",
		"assemblyAssignment", "assemblyIdentifierOrList", "assemblyIdentifierList",
		"assemblyStackAssignment", "labelDefinition", "assemblySwitch", "assemblyCase",
		"assemblyFunctionDefinition", "assemblyFunctionReturns", "assemblyFor",
		"assemblyIf", "assemblyLiteral", "tupleExpression", "numberLiteral",
		"identifier", "hexLiteral", "overrideSpecifier", "stringLiteral",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 133, 1169, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
		0, 1, 0, 5, 0, 213, 8, 0, 10, 0, 12, 0, 216, 9, 0, 1, 0, 1, 0, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 3, 3, 230, 8, 3, 1,
		4, 1, 4, 3, 4, 234, 8, 4, 1, 4, 5, 4, 237, 8, 4, 10, 4, 12, 4, 240, 9,
		4, 1, 5, 1, 5, 1, 6, 3, 6, 245, 8, 6, 1, 6, 1, 6, 3, 6, 249, 8, 6, 1, 6,
		3, 6, 252, 8, 6, 1, 7, 1, 7, 1, 7, 3, 7, 257, 8, 7, 1, 8, 1, 8, 1, 8, 1,
		8, 3, 8, 263, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 270, 8, 8, 1, 8,
		1, 8, 3, 8, 274, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 5, 8, 285, 8, 8, 10, 8, 12, 8, 288, 9, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 3, 8, 295, 8, 8, 1, 9, 1, 9, 1, 10, 3, 10, 300, 8, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 308, 8, 10, 10, 10, 12, 10, 311,
		9, 10, 3, 10, 313, 8, 10, 1, 10, 1, 10, 5, 10, 317, 8, 10, 10, 10, 12,
		10, 320, 9, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 3, 11, 327, 8, 11, 1,
		11, 3, 11, 330, 8, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 3, 12, 341, 8, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 5, 13, 350, 8, 13, 10, 13, 12, 13, 353, 9, 13, 1, 13, 1, 13,
		1, 13, 3, 13, 358, 8, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 385, 8,
		17, 1, 17, 3, 17, 388, 8, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18,
		1, 18, 5, 18, 397, 8, 18, 10, 18, 12, 18, 400, 9, 18, 1, 18, 1, 18, 3,
		18, 404, 8, 18, 1, 19, 1, 19, 1, 19, 3, 19, 409, 8, 19, 1, 20, 1, 20, 1,
		21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 421, 8, 21,
		10, 21, 12, 21, 424, 9, 21, 3, 21, 426, 8, 21, 1, 21, 1, 21, 1, 22, 1,
		22, 1, 22, 3, 22, 433, 8, 22, 1, 22, 1, 22, 5, 22, 437, 8, 22, 10, 22,
		12, 22, 440, 9, 22, 1, 22, 1, 22, 3, 22, 444, 8, 22, 1, 23, 1, 23, 1, 23,
		3, 23, 449, 8, 23, 1, 23, 3, 23, 452, 8, 23, 1, 24, 1, 24, 1, 24, 1, 24,
		3, 24, 458, 8, 24, 1, 24, 1, 24, 3, 24, 462, 8, 24, 1, 25, 1, 25, 3, 25,
		466, 8, 25, 1, 25, 1, 25, 1, 25, 3, 25, 471, 8, 25, 1, 26, 1, 26, 1, 26,
		1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 5, 27, 484, 8,
		27, 10, 27, 12, 27, 487, 9, 27, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 493,
		8, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 503,
		8, 30, 1, 30, 1, 30, 5, 30, 507, 8, 30, 10, 30, 12, 30, 510, 9, 30, 1,
		30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 31, 5, 31, 518, 8, 31, 10, 31, 12, 31,
		521, 9, 31, 3, 31, 523, 8, 31, 1, 31, 1, 31, 1, 32, 1, 32, 3, 32, 529,
		8, 32, 1, 32, 3, 32, 532, 8, 32, 1, 33, 1, 33, 1, 33, 1, 33, 5, 33, 538,
		8, 33, 10, 33, 12, 33, 541, 9, 33, 3, 33, 543, 8, 33, 1, 33, 1, 33, 1,
		34, 1, 34, 3, 34, 549, 8, 34, 1, 34, 3, 34, 552, 8, 34, 1, 35, 1, 35, 1,
		35, 1, 35, 5, 35, 558, 8, 35, 10, 35, 12, 35, 561, 9, 35, 3, 35, 563, 8,
		35, 1, 35, 1, 35, 1, 36, 1, 36, 3, 36, 569, 8, 36, 1, 37, 1, 37, 3, 37,
		573, 8, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1,
		38, 3, 38, 584, 8, 38, 1, 38, 1, 38, 1, 38, 3, 38, 589, 8, 38, 1, 38, 5,
		38, 592, 8, 38, 10, 38, 12, 38, 595, 9, 38, 1, 39, 1, 39, 1, 39, 5, 39,
		600, 8, 39, 10, 39, 12, 39, 603, 9, 39, 1, 40, 1, 40, 3, 40, 607, 8, 40,
		1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 613, 8, 41, 1, 41, 1, 41, 1, 41, 3,
		41, 618, 8, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 43, 1, 43, 1, 44, 1, 44,
		1, 44, 1, 44, 1, 44, 5, 44, 631, 8, 44, 10, 44, 12, 44, 634, 9, 44, 1,
		44, 1, 44, 3, 44, 638, 8, 44, 1, 45, 1, 45, 1, 46, 1, 46, 1, 47, 1, 47,
		5, 47, 646, 8, 47, 10, 47, 12, 47, 649, 9, 47, 1, 47, 1, 47, 1, 48, 1,
		48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48,
		1, 48, 1, 48, 1, 48, 3, 48, 668, 8, 48, 1, 49, 1, 49, 1, 49, 1, 50, 1,
		50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 680, 8, 50, 1, 51, 1, 51,
		1, 51, 3, 51, 685, 8, 51, 1, 51, 1, 51, 4, 51, 689, 8, 51, 11, 51, 12,
		51, 690, 1, 52, 1, 52, 3, 52, 695, 8, 52, 1, 52, 3, 52, 698, 8, 52, 1,
		52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 3, 54,
		710, 8, 54, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 719,
		8, 56, 1, 56, 1, 56, 3, 56, 723, 8, 56, 1, 56, 3, 56, 726, 8, 56, 1, 56,
		1, 56, 1, 56, 1, 57, 1, 57, 3, 57, 733, 8, 57, 1, 57, 1, 57, 1, 57, 1,
		57, 3, 57, 739, 8, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59,
		1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 61, 1, 61, 1,
		61, 1, 62, 1, 62, 3, 62, 761, 8, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63,
		1, 64, 1, 64, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1,
		66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 783, 8, 66, 1, 66, 1, 66, 3, 66,
		787, 8, 66, 1, 66, 1, 66, 1, 67, 3, 67, 792, 8, 67, 1, 67, 1, 67, 3, 67,
		796, 8, 67, 5, 67, 798, 8, 67, 10, 67, 12, 67, 801, 9, 67, 1, 68, 1, 68,
		3, 68, 805, 8, 68, 1, 68, 5, 68, 808, 8, 68, 10, 68, 12, 68, 811, 9, 68,
		1, 68, 3, 68, 814, 8, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 70, 1, 70, 1,
		70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70,
		1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 838, 8, 70, 1, 70, 1, 70, 1,
		70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70,
		1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1,
		70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70,
		1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1,
		70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 892, 8, 70,
		1, 70, 1, 70, 3, 70, 896, 8, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1,
		70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 5, 70, 912,
		8, 70, 10, 70, 12, 70, 915, 9, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1,
		71, 1, 71, 1, 71, 1, 71, 3, 71, 926, 8, 71, 1, 72, 1, 72, 1, 72, 5, 72,
		931, 8, 72, 10, 72, 12, 72, 934, 9, 72, 1, 73, 1, 73, 1, 73, 5, 73, 939,
		8, 73, 10, 73, 12, 73, 942, 9, 73, 1, 73, 3, 73, 945, 8, 73, 1, 74, 1,
		74, 1, 74, 1, 74, 1, 75, 1, 75, 3, 75, 953, 8, 75, 1, 75, 1, 75, 3, 75,
		957, 8, 75, 3, 75, 959, 8, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 77,
		1, 77, 5, 77, 968, 8, 77, 10, 77, 12, 77, 971, 9, 77, 1, 77, 1, 77, 1,
		78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78,
		1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 992, 8, 78, 1, 79, 1,
		79, 1, 79, 3, 79, 997, 8, 79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 81, 1, 81,
		1, 81, 1, 81, 3, 81, 1007, 8, 81, 1, 81, 1, 81, 3, 81, 1011, 8, 81, 1,
		81, 1, 81, 5, 81, 1015, 8, 81, 10, 81, 12, 81, 1018, 9, 81, 1, 81, 3, 81,
		1021, 8, 81, 1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1027, 8, 82, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84,
		1040, 8, 84, 1, 85, 1, 85, 1, 85, 5, 85, 1045, 8, 85, 10, 85, 12, 85, 1048,
		9, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1,
		88, 5, 88, 1060, 8, 88, 10, 88, 12, 88, 1063, 9, 88, 1, 89, 1, 89, 1, 89,
		1, 89, 1, 89, 1, 89, 3, 89, 1071, 8, 89, 1, 90, 1, 90, 1, 90, 1, 90, 3,
		90, 1077, 8, 90, 1, 90, 1, 90, 3, 90, 1081, 8, 90, 1, 90, 1, 90, 1, 91,
		1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 3, 92, 1091, 8, 92, 1, 92, 1, 92, 1,
		92, 3, 92, 1096, 8, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 94,
		1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 1109, 8, 94, 1, 95, 1, 95, 3, 95, 1113,
		8, 95, 1, 95, 1, 95, 3, 95, 1117, 8, 95, 5, 95, 1119, 8, 95, 10, 95, 12,
		95, 1122, 9, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 5, 95, 1129, 8, 95,
		10, 95, 12, 95, 1132, 9, 95, 3, 95, 1134, 8, 95, 1, 95, 3, 95, 1137, 8,
		95, 1, 96, 1, 96, 3, 96, 1141, 8, 96, 1, 97, 1, 97, 1, 98, 4, 98, 1146,
		8, 98, 11, 98, 12, 98, 1147, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 5, 99,
		1155, 8, 99, 10, 99, 12, 99, 1158, 9, 99, 1, 99, 1, 99, 3, 99, 1162, 8,
		99, 1, 100, 4, 100, 1165, 8, 100, 11, 100, 12, 100, 1166, 1, 100, 0, 2,
		76, 140, 101, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,
		32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66,
		68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102,
		104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132,
		134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162,
		164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192,
		194, 196, 198, 200, 0, 15, 1, 0, 5, 11, 1, 0, 19, 21, 3, 0, 3, 3, 5, 10,
		28, 35, 1, 0, 48, 50, 4, 0, 110, 110, 117, 117, 121, 121, 123, 123, 3,
		0, 44, 44, 63, 66, 97, 101, 1, 0, 67, 68, 1, 0, 30, 31, 2, 0, 3, 3, 32,
		33, 1, 0, 74, 75, 1, 0, 7, 10, 1, 0, 34, 35, 2, 0, 11, 11, 78, 87, 1, 0,
		103, 104, 10, 0, 14, 14, 25, 25, 44, 44, 50, 50, 62, 62, 95, 95, 113, 113,
		117, 117, 125, 125, 127, 128, 1297, 0, 214, 1, 0, 0, 0, 2, 219, 1, 0, 0,
		0, 4, 224, 1, 0, 0, 0, 6, 229, 1, 0, 0, 0, 8, 231, 1, 0, 0, 0, 10, 241,
		1, 0, 0, 0, 12, 251, 1, 0, 0, 0, 14, 253, 1, 0, 0, 0, 16, 294, 1, 0, 0,
		0, 18, 296, 1, 0, 0, 0, 20, 299, 1, 0, 0, 0, 22, 323, 1, 0, 0, 0, 24, 340,
		1, 0, 0, 0, 26, 342, 1, 0, 0, 0, 28, 361, 1, 0, 0, 0, 30, 368, 1, 0, 0,
		0, 32, 373, 1, 0, 0, 0, 34, 379, 1, 0, 0, 0, 36, 403, 1, 0, 0, 0, 38, 405,
		1, 0, 0, 0, 40, 410, 1, 0, 0, 0, 42, 412, 1, 0, 0, 0, 44, 429, 1, 0, 0,
		0, 46, 445, 1, 0, 0, 0, 48, 453, 1, 0, 0, 0, 50, 470, 1, 0, 0, 0, 52, 472,
		1, 0, 0, 0, 54, 485, 1, 0, 0, 0, 56, 488, 1, 0, 0, 0, 58, 496, 1, 0, 0,
		0, 60, 498, 1, 0, 0, 0, 62, 513, 1, 0, 0, 0, 64, 526, 1, 0, 0, 0, 66, 533,
		1, 0, 0, 0, 68, 546, 1, 0, 0, 0, 70, 553, 1, 0, 0, 0, 72, 566, 1, 0, 0,
		0, 74, 570, 1, 0, 0, 0, 76, 583, 1, 0, 0, 0, 78, 596, 1, 0, 0, 0, 80, 606,
		1, 0, 0, 0, 82, 608, 1, 0, 0, 0, 84, 621, 1, 0, 0, 0, 86, 623, 1, 0, 0,
		0, 88, 625, 1, 0, 0, 0, 90, 639, 1, 0, 0, 0, 92, 641, 1, 0, 0, 0, 94, 643,
		1, 0, 0, 0, 96, 667, 1, 0, 0, 0, 98, 669, 1, 0, 0, 0, 100, 672, 1, 0, 0,
		0, 102, 681, 1, 0, 0, 0, 104, 692, 1, 0, 0, 0, 106, 701, 1, 0, 0, 0, 108,
		709, 1, 0, 0, 0, 110, 711, 1, 0, 0, 0, 112, 714, 1, 0, 0, 0, 114, 730,
		1, 0, 0, 0, 116, 742, 1, 0, 0, 0, 118, 744, 1, 0, 0, 0, 120, 752, 1, 0,
		0, 0, 122, 755, 1, 0, 0, 0, 124, 758, 1, 0, 0, 0, 126, 764, 1, 0, 0, 0,
		128, 767, 1, 0, 0, 0, 130, 771, 1, 0, 0, 0, 132, 782, 1, 0, 0, 0, 134,
		791, 1, 0, 0, 0, 136, 802, 1, 0, 0, 0, 138, 817, 1, 0, 0, 0, 140, 837,
		1, 0, 0, 0, 142, 925, 1, 0, 0, 0, 144, 927, 1, 0, 0, 0, 146, 935, 1, 0,
		0, 0, 148, 946, 1, 0, 0, 0, 150, 958, 1, 0, 0, 0, 152, 960, 1, 0, 0, 0,
		154, 965, 1, 0, 0, 0, 156, 991, 1, 0, 0, 0, 158, 996, 1, 0, 0, 0, 160,
		998, 1, 0, 0, 0, 162, 1006, 1, 0, 0, 0, 164, 1022, 1, 0, 0, 0, 166, 1028,
		1, 0, 0, 0, 168, 1039, 1, 0, 0, 0, 170, 1041, 1, 0, 0, 0, 172, 1049, 1,
		0, 0, 0, 174, 1053, 1, 0, 0, 0, 176, 1056, 1, 0, 0, 0, 178, 1070, 1, 0,
		0, 0, 180, 1072, 1, 0, 0, 0, 182, 1084, 1, 0, 0, 0, 184, 1087, 1, 0, 0,
		0, 186, 1099, 1, 0, 0, 0, 188, 1108, 1, 0, 0, 0, 190, 1136, 1, 0, 0, 0,
		192, 1138, 1, 0, 0, 0, 194, 1142, 1, 0, 0, 0, 196, 1145, 1, 0, 0, 0, 198,
		1149, 1, 0, 0, 0, 200, 1164, 1, 0, 0, 0, 202, 213, 3, 2, 1, 0, 203, 213,
		3, 16, 8, 0, 204, 213, 3, 20, 10, 0, 205, 213, 3, 60, 30, 0, 206, 213,
		3, 42, 21, 0, 207, 213, 3, 48, 24, 0, 208, 213, 3, 28, 14, 0, 209, 213,
		3, 30, 15, 0, 210, 213, 3, 32, 16, 0, 211, 213, 3, 34, 17, 0, 212, 202,
		1, 0, 0, 0, 212, 203, 1, 0, 0, 0, 212, 204, 1, 0, 0, 0, 212, 205, 1, 0,
		0, 0, 212, 206, 1, 0, 0, 0, 212, 207, 1, 0, 0, 0, 212, 208, 1, 0, 0, 0,
		212, 209, 1, 0, 0, 0, 212, 210, 1, 0, 0, 0, 212, 211, 1, 0, 0, 0, 213,
		216, 1, 0, 0, 0, 214, 212, 1, 0, 0, 0, 214, 215, 1, 0, 0, 0, 215, 217,
		1, 0, 0, 0, 216, 214, 1, 0, 0, 0, 217, 218, 5, 0, 0, 1, 218, 1, 1, 0, 0,
		0, 219, 220, 5, 1, 0, 0, 220, 221, 3, 4, 2, 0, 221, 222, 3, 6, 3, 0, 222,
		223, 5, 2, 0, 0, 223, 3, 1, 0, 0, 0, 224, 225, 3, 194, 97, 0, 225, 5, 1,
		0, 0, 0, 226, 230, 5, 3, 0, 0, 227, 230, 3, 8, 4, 0, 228, 230, 3, 140,
		70, 0, 229, 226, 1, 0, 0, 0, 229, 227, 1, 0, 0, 0, 229, 228, 1, 0, 0, 0,
		230, 7, 1, 0, 0, 0, 231, 238, 3, 12, 6, 0, 232, 234, 5, 4, 0, 0, 233, 232,
		1, 0, 0, 0, 233, 234, 1, 0, 0, 0, 234, 235, 1, 0, 0, 0, 235, 237, 3, 12,
		6, 0, 236, 233, 1, 0, 0, 0, 237, 240, 1, 0, 0, 0, 238, 236, 1, 0, 0, 0,
		238, 239, 1, 0, 0, 0, 239, 9, 1, 0, 0, 0, 240, 238, 1, 0, 0, 0, 241, 242,
		7, 0, 0, 0, 242, 11, 1, 0, 0, 0, 243, 245, 3, 10, 5, 0, 244, 243, 1, 0,
		0, 0, 244, 245, 1, 0, 0, 0, 245, 246, 1, 0, 0, 0, 246, 252, 5, 130, 0,
		0, 247, 249, 3, 10, 5, 0, 248, 247, 1, 0, 0, 0, 248, 249, 1, 0, 0, 0, 249,
		250, 1, 0, 0, 0, 250, 252, 5, 103, 0, 0, 251, 244, 1, 0, 0, 0, 251, 248,
		1, 0, 0, 0, 252, 13, 1, 0, 0, 0, 253, 256, 3, 194, 97, 0, 254, 255, 5,
		12, 0, 0, 255, 257, 3, 194, 97, 0, 256, 254, 1, 0, 0, 0, 256, 257, 1, 0,
		0, 0, 257, 15, 1, 0, 0, 0, 258, 259, 5, 13, 0, 0, 259, 262, 3, 18, 9, 0,
		260, 261, 5, 12, 0, 0, 261, 263, 3, 194, 97, 0, 262, 260, 1, 0, 0, 0, 262,
		263, 1, 0, 0, 0, 263, 264, 1, 0, 0, 0, 264, 265, 5, 2, 0, 0, 265, 295,
		1, 0, 0, 0, 266, 269, 5, 13, 0, 0, 267, 270, 5, 3, 0, 0, 268, 270, 3, 194,
		97, 0, 269, 267, 1, 0, 0, 0, 269, 268, 1, 0, 0, 0, 270, 273, 1, 0, 0, 0,
		271, 272, 5, 12, 0, 0, 272, 274, 3, 194, 97, 0, 273, 271, 1, 0, 0, 0, 273,
		274, 1, 0, 0, 0, 274, 275, 1, 0, 0, 0, 275, 276, 5, 14, 0, 0, 276, 277,
		3, 18, 9, 0, 277, 278, 5, 2, 0, 0, 278, 295, 1, 0, 0, 0, 279, 280, 5, 13,
		0, 0, 280, 281, 5, 15, 0, 0, 281, 286, 3, 14, 7, 0, 282, 283, 5, 16, 0,
		0, 283, 285, 3, 14, 7, 0, 284, 282, 1, 0, 0, 0, 285, 288, 1, 0, 0, 0, 286,
		284, 1, 0, 0, 0, 286, 287, 1, 0, 0, 0, 287, 289, 1, 0, 0, 0, 288, 286,
		1, 0, 0, 0, 289, 290, 5, 17, 0, 0, 290, 291, 5, 14, 0, 0, 291, 292, 3,
		18, 9, 0, 292, 293, 5, 2, 0, 0, 293, 295, 1, 0, 0, 0, 294, 258, 1, 0, 0,
		0, 294, 266, 1, 0, 0, 0, 294, 279, 1, 0, 0, 0, 295, 17, 1, 0, 0, 0, 296,
		297, 5, 129, 0, 0, 297, 19, 1, 0, 0, 0, 298, 300, 5, 18, 0, 0, 299, 298,
		1, 0, 0, 0, 299, 300, 1, 0, 0, 0, 300, 301, 1, 0, 0, 0, 301, 302, 7, 1,
		0, 0, 302, 312, 3, 194, 97, 0, 303, 304, 5, 22, 0, 0, 304, 309, 3, 22,
		11, 0, 305, 306, 5, 16, 0, 0, 306, 308, 3, 22, 11, 0, 307, 305, 1, 0, 0,
		0, 308, 311, 1, 0, 0, 0, 309, 307, 1, 0, 0, 0, 309, 310, 1, 0, 0, 0, 310,
		313, 1, 0, 0, 0, 311, 309, 1, 0, 0, 0, 312, 303, 1, 0, 0, 0, 312, 313,
		1, 0, 0, 0, 313, 314, 1, 0, 0, 0, 314, 318, 5, 15, 0, 0, 315, 317, 3, 24,
		12, 0, 316, 315, 1, 0, 0, 0, 317, 320, 1, 0, 0, 0, 318, 316, 1, 0, 0, 0,
		318, 319, 1, 0, 0, 0, 319, 321, 1, 0, 0, 0, 320, 318, 1, 0, 0, 0, 321,
		322, 5, 17, 0, 0, 322, 21, 1, 0, 0, 0, 323, 329, 3, 78, 39, 0, 324, 326,
		5, 23, 0, 0, 325, 327, 3, 144, 72, 0, 326, 325, 1, 0, 0, 0, 326, 327, 1,
		0, 0, 0, 327, 328, 1, 0, 0, 0, 328, 330, 5, 24, 0, 0, 329, 324, 1, 0, 0,
		0, 329, 330, 1, 0, 0, 0, 330, 23, 1, 0, 0, 0, 331, 341, 3, 26, 13, 0, 332,
		341, 3, 34, 17, 0, 333, 341, 3, 42, 21, 0, 334, 341, 3, 44, 22, 0, 335,
		341, 3, 48, 24, 0, 336, 341, 3, 56, 28, 0, 337, 341, 3, 60, 30, 0, 338,
		341, 3, 30, 15, 0, 339, 341, 3, 32, 16, 0, 340, 331, 1, 0, 0, 0, 340, 332,
		1, 0, 0, 0, 340, 333, 1, 0, 0, 0, 340, 334, 1, 0, 0, 0, 340, 335, 1, 0,
		0, 0, 340, 336, 1, 0, 0, 0, 340, 337, 1, 0, 0, 0, 340, 338, 1, 0, 0, 0,
		340, 339, 1, 0, 0, 0, 341, 25, 1, 0, 0, 0, 342, 351, 3, 76, 38, 0, 343,
		350, 5, 119, 0, 0, 344, 350, 5, 116, 0, 0, 345, 350, 5, 118, 0, 0, 346,
		350, 5, 110, 0, 0, 347, 350, 5, 111, 0, 0, 348, 350, 3, 198, 99, 0, 349,
		343, 1, 0, 0, 0, 349, 344, 1, 0, 0, 0, 349, 345, 1, 0, 0, 0, 349, 346,
		1, 0, 0, 0, 349, 347, 1, 0, 0, 0, 349, 348, 1, 0, 0, 0, 350, 353, 1, 0,
		0, 0, 351, 349, 1, 0, 0, 0, 351, 352, 1, 0, 0, 0, 352, 354, 1, 0, 0, 0,
		353, 351, 1, 0, 0, 0, 354, 357, 3, 194, 97, 0, 355, 356, 5, 11, 0, 0, 356,
		358, 3, 140, 70, 0, 357, 355, 1, 0, 0, 0, 357, 358, 1, 0, 0, 0, 358, 359,
		1, 0, 0, 0, 359, 360, 5, 2, 0, 0, 360, 27, 1, 0, 0, 0, 361, 362, 3, 76,
		38, 0, 362, 363, 5, 110, 0, 0, 363, 364, 3, 194, 97, 0, 364, 365, 5, 11,
		0, 0, 365, 366, 3, 140, 70, 0, 366, 367, 5, 2, 0, 0, 367, 29, 1, 0, 0,
		0, 368, 369, 5, 25, 0, 0, 369, 370, 3, 194, 97, 0, 370, 371, 3, 62, 31,
		0, 371, 372, 5, 2, 0, 0, 372, 31, 1, 0, 0, 0, 373, 374, 5, 122, 0, 0, 374,
		375, 3, 194, 97, 0, 375, 376, 5, 22, 0, 0, 376, 377, 3, 138, 69, 0, 377,
		378, 5, 2, 0, 0, 378, 33, 1, 0, 0, 0, 379, 380, 5, 26, 0, 0, 380, 381,
		3, 36, 18, 0, 381, 384, 5, 27, 0, 0, 382, 385, 5, 3, 0, 0, 383, 385, 3,
		76, 38, 0, 384, 382, 1, 0, 0, 0, 384, 383, 1, 0, 0, 0, 385, 387, 1, 0,
		0, 0, 386, 388, 5, 124, 0, 0, 387, 386, 1, 0, 0, 0, 387, 388, 1, 0, 0,
		0, 388, 389, 1, 0, 0, 0, 389, 390, 5, 2, 0, 0, 390, 35, 1, 0, 0, 0, 391,
		404, 3, 78, 39, 0, 392, 393, 5, 15, 0, 0, 393, 398, 3, 38, 19, 0, 394,
		395, 5, 16, 0, 0, 395, 397, 3, 38, 19, 0, 396, 394, 1, 0, 0, 0, 397, 400,
		1, 0, 0, 0, 398, 396, 1, 0, 0, 0, 398, 399, 1, 0, 0, 0, 399, 401, 1, 0,
		0, 0, 400, 398, 1, 0, 0, 0, 401, 402, 5, 17, 0, 0, 402, 404, 1, 0, 0, 0,
		403, 391, 1, 0, 0, 0, 403, 392, 1, 0, 0, 0, 404, 37, 1, 0, 0, 0, 405, 408,
		3, 78, 39, 0, 406, 407, 5, 12, 0, 0, 407, 409, 3, 40, 20, 0, 408, 406,
		1, 0, 0, 0, 408, 409, 1, 0, 0, 0, 409, 39, 1, 0, 0, 0, 410, 411, 7, 2,
		0, 0, 411, 41, 1, 0, 0, 0, 412, 413, 5, 36, 0, 0, 413, 414, 3, 194, 97,
		0, 414, 425, 5, 15, 0, 0, 415, 416, 3, 74, 37, 0, 416, 422, 5, 2, 0, 0,
		417, 418, 3, 74, 37, 0, 418, 419, 5, 2, 0, 0, 419, 421, 1, 0, 0, 0, 420,
		417, 1, 0, 0, 0, 421, 424, 1, 0, 0, 0, 422, 420, 1, 0, 0, 0, 422, 423,
		1, 0, 0, 0, 423, 426, 1, 0, 0, 0, 424, 422, 1, 0, 0, 0, 425, 415, 1, 0,
		0, 0, 425, 426, 1, 0, 0, 0, 426, 427, 1, 0, 0, 0, 427, 428, 5, 17, 0, 0,
		428, 43, 1, 0, 0, 0, 429, 430, 5, 37, 0, 0, 430, 432, 3, 194, 97, 0, 431,
		433, 3, 62, 31, 0, 432, 431, 1, 0, 0, 0, 432, 433, 1, 0, 0, 0, 433, 438,
		1, 0, 0, 0, 434, 437, 5, 120, 0, 0, 435, 437, 3, 198, 99, 0, 436, 434,
		1, 0, 0, 0, 436, 435, 1, 0, 0, 0, 437, 440, 1, 0, 0, 0, 438, 436, 1, 0,
		0, 0, 438, 439, 1, 0, 0, 0, 439, 443, 1, 0, 0, 0, 440, 438, 1, 0, 0, 0,
		441, 444, 5, 2, 0, 0, 442, 444, 3, 94, 47, 0, 443, 441, 1, 0, 0, 0, 443,
		442, 1, 0, 0, 0, 444, 45, 1, 0, 0, 0, 445, 451, 3, 194, 97, 0, 446, 448,
		5, 23, 0, 0, 447, 449, 3, 144, 72, 0, 448, 447, 1, 0, 0, 0, 448, 449, 1,
		0, 0, 0, 449, 450, 1, 0, 0, 0, 450, 452, 5, 24, 0, 0, 451, 446, 1, 0, 0,
		0, 451, 452, 1, 0, 0, 0, 452, 47, 1, 0, 0, 0, 453, 454, 3, 50, 25, 0, 454,
		455, 3, 62, 31, 0, 455, 457, 3, 54, 27, 0, 456, 458, 3, 52, 26, 0, 457,
		456, 1, 0, 0, 0, 457, 458, 1, 0, 0, 0, 458, 461, 1, 0, 0, 0, 459, 462,
		5, 2, 0, 0, 460, 462, 3, 94, 47, 0, 461, 459, 1, 0, 0, 0, 461, 460, 1,
		0, 0, 0, 462, 49, 1, 0, 0, 0, 463, 465, 5, 38, 0, 0, 464, 466, 3, 194,
		97, 0, 465, 464, 1, 0, 0, 0, 465, 466, 1, 0, 0, 0, 466, 471, 1, 0, 0, 0,
		467, 471, 5, 125, 0, 0, 468, 471, 5, 126, 0, 0, 469, 471, 5, 127, 0, 0,
		470, 463, 1, 0, 0, 0, 470, 467, 1, 0, 0, 0, 470, 468, 1, 0, 0, 0, 470,
		469, 1, 0, 0, 0, 471, 51, 1, 0, 0, 0, 472, 473, 5, 39, 0, 0, 473, 474,
		3, 62, 31, 0, 474, 53, 1, 0, 0, 0, 475, 484, 5, 114, 0, 0, 476, 484, 5,
		119, 0, 0, 477, 484, 5, 116, 0, 0, 478, 484, 5, 118, 0, 0, 479, 484, 5,
		120, 0, 0, 480, 484, 3, 92, 46, 0, 481, 484, 3, 46, 23, 0, 482, 484, 3,
		198, 99, 0, 483, 475, 1, 0, 0, 0, 483, 476, 1, 0, 0, 0, 483, 477, 1, 0,
		0, 0, 483, 478, 1, 0, 0, 0, 483, 479, 1, 0, 0, 0, 483, 480, 1, 0, 0, 0,
		483, 481, 1, 0, 0, 0, 483, 482, 1, 0, 0, 0, 484, 487, 1, 0, 0, 0, 485,
		483, 1, 0, 0, 0, 485, 486, 1, 0, 0, 0, 486, 55, 1, 0, 0, 0, 487, 485, 1,
		0, 0, 0, 488, 489, 5, 40, 0, 0, 489, 490, 3, 194, 97, 0, 490, 492, 3, 66,
		33, 0, 491, 493, 5, 108, 0, 0, 492, 491, 1, 0, 0, 0, 492, 493, 1, 0, 0,
		0, 493, 494, 1, 0, 0, 0, 494, 495, 5, 2, 0, 0, 495, 57, 1, 0, 0, 0, 496,
		497, 3, 194, 97, 0, 497, 59, 1, 0, 0, 0, 498, 499, 5, 41, 0, 0, 499, 500,
		3, 194, 97, 0, 500, 502, 5, 15, 0, 0, 501, 503, 3, 58, 29, 0, 502, 501,
		1, 0, 0, 0, 502, 503, 1, 0, 0, 0, 503, 508, 1, 0, 0, 0, 504, 505, 5, 16,
		0, 0, 505, 507, 3, 58, 29, 0, 506, 504, 1, 0, 0, 0, 507, 510, 1, 0, 0,
		0, 508, 506, 1, 0, 0, 0, 508, 509, 1, 0, 0, 0, 509, 511, 1, 0, 0, 0, 510,
		508, 1, 0, 0, 0, 511, 512, 5, 17, 0, 0, 512, 61, 1, 0, 0, 0, 513, 522,
		5, 23, 0, 0, 514, 519, 3, 64, 32, 0, 515, 516, 5, 16, 0, 0, 516, 518, 3,
		64, 32, 0, 517, 515, 1, 0, 0, 0, 518, 521, 1, 0, 0, 0, 519, 517, 1, 0,
		0, 0, 519, 520, 1, 0, 0, 0, 520, 523, 1, 0, 0, 0, 521, 519, 1, 0, 0, 0,
		522, 514, 1, 0, 0, 0, 522, 523, 1, 0, 0, 0, 523, 524, 1, 0, 0, 0, 524,
		525, 5, 24, 0, 0, 525, 63, 1, 0, 0, 0, 526, 528, 3, 76, 38, 0, 527, 529,
		3, 90, 45, 0, 528, 527, 1, 0, 0, 0, 528, 529, 1, 0, 0, 0, 529, 531, 1,
		0, 0, 0, 530, 532, 3, 194, 97, 0, 531, 530, 1, 0, 0, 0, 531, 532, 1, 0,
		0, 0, 532, 65, 1, 0, 0, 0, 533, 542, 5, 23, 0, 0, 534, 539, 3, 68, 34,
		0, 535, 536, 5, 16, 0, 0, 536, 538, 3, 68, 34, 0, 537, 535, 1, 0, 0, 0,
		538, 541, 1, 0, 0, 0, 539, 537, 1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540,
		543, 1, 0, 0, 0, 541, 539, 1, 0, 0, 0, 542, 534, 1, 0, 0, 0, 542, 543,
		1, 0, 0, 0, 543, 544, 1, 0, 0, 0, 544, 545, 5, 24, 0, 0, 545, 67, 1, 0,
		0, 0, 546, 548, 3, 76, 38, 0, 547, 549, 5, 115, 0, 0, 548, 547, 1, 0, 0,
		0, 548, 549, 1, 0, 0, 0, 549, 551, 1, 0, 0, 0, 550, 552, 3, 194, 97, 0,
		551, 550, 1, 0, 0, 0, 551, 552, 1, 0, 0, 0, 552, 69, 1, 0, 0, 0, 553, 562,
		5, 23, 0, 0, 554, 559, 3, 72, 36, 0, 555, 556, 5, 16, 0, 0, 556, 558, 3,
		72, 36, 0, 557, 555, 1, 0, 0, 0, 558, 561, 1, 0, 0, 0, 559, 557, 1, 0,
		0, 0, 559, 560, 1, 0, 0, 0, 560, 563, 1, 0, 0, 0, 561, 559, 1, 0, 0, 0,
		562, 554, 1, 0, 0, 0, 562, 563, 1, 0, 0, 0, 563, 564, 1, 0, 0, 0, 564,
		565, 5, 24, 0, 0, 565, 71, 1, 0, 0, 0, 566, 568, 3, 76, 38, 0, 567, 569,
		3, 90, 45, 0, 568, 567, 1, 0, 0, 0, 568, 569, 1, 0, 0, 0, 569, 73, 1, 0,
		0, 0, 570, 572, 3, 76, 38, 0, 571, 573, 3, 90, 45, 0, 572, 571, 1, 0, 0,
		0, 572, 573, 1, 0, 0, 0, 573, 574, 1, 0, 0, 0, 574, 575, 3, 194, 97, 0,
		575, 75, 1, 0, 0, 0, 576, 577, 6, 38, -1, 0, 577, 584, 3, 138, 69, 0, 578,
		584, 3, 78, 39, 0, 579, 584, 3, 82, 41, 0, 580, 584, 3, 88, 44, 0, 581,
		582, 5, 44, 0, 0, 582, 584, 5, 117, 0, 0, 583, 576, 1, 0, 0, 0, 583, 578,
		1, 0, 0, 0, 583, 579, 1, 0, 0, 0, 583, 580, 1, 0, 0, 0, 583, 581, 1, 0,
		0, 0, 584, 593, 1, 0, 0, 0, 585, 586, 10, 3, 0, 0, 586, 588, 5, 42, 0,
		0, 587, 589, 3, 140, 70, 0, 588, 587, 1, 0, 0, 0, 588, 589, 1, 0, 0, 0,
		589, 590, 1, 0, 0, 0, 590, 592, 5, 43, 0, 0, 591, 585, 1, 0, 0, 0, 592,
		595, 1, 0, 0, 0, 593, 591, 1, 0, 0, 0, 593, 594, 1, 0, 0, 0, 594, 77, 1,
		0, 0, 0, 595, 593, 1, 0, 0, 0, 596, 601, 3, 194, 97, 0, 597, 598, 5, 45,
		0, 0, 598, 600, 3, 194, 97, 0, 599, 597, 1, 0, 0, 0, 600, 603, 1, 0, 0,
		0, 601, 599, 1, 0, 0, 0, 601, 602, 1, 0, 0, 0, 602, 79, 1, 0, 0, 0, 603,
		601, 1, 0, 0, 0, 604, 607, 3, 138, 69, 0, 605, 607, 3, 78, 39, 0, 606,
		604, 1, 0, 0, 0, 606, 605, 1, 0, 0, 0, 607, 81, 1, 0, 0, 0, 608, 609, 5,
		46, 0, 0, 609, 610, 5, 23, 0, 0, 610, 612, 3, 80, 40, 0, 611, 613, 3, 84,
		42, 0, 612, 611, 1, 0, 0, 0, 612, 613, 1, 0, 0, 0, 613, 614, 1, 0, 0, 0,
		614, 615, 5, 47, 0, 0, 615, 617, 3, 76, 38, 0, 616, 618, 3, 86, 43, 0,
		617, 616, 1, 0, 0, 0, 617, 618, 1, 0, 0, 0, 618, 619, 1, 0, 0, 0, 619,
		620, 5, 24, 0, 0, 620, 83, 1, 0, 0, 0, 621, 622, 3, 194, 97, 0, 622, 85,
		1, 0, 0, 0, 623, 624, 3, 194, 97, 0, 624, 87, 1, 0, 0, 0, 625, 626, 5,
		38, 0, 0, 626, 632, 3, 70, 35, 0, 627, 631, 5, 116, 0, 0, 628, 631, 5,
		114, 0, 0, 629, 631, 3, 92, 46, 0, 630, 627, 1, 0, 0, 0, 630, 628, 1, 0,
		0, 0, 630, 629, 1, 0, 0, 0, 631, 634, 1, 0, 0, 0, 632, 630, 1, 0, 0, 0,
		632, 633, 1, 0, 0, 0, 633, 637, 1, 0, 0, 0, 634, 632, 1, 0, 0, 0, 635,
		636, 5, 39, 0, 0, 636, 638, 3, 70, 35, 0, 637, 635, 1, 0, 0, 0, 637, 638,
		1, 0, 0, 0, 638, 89, 1, 0, 0, 0, 639, 640, 7, 3, 0, 0, 640, 91, 1, 0, 0,
		0, 641, 642, 7, 4, 0, 0, 642, 93, 1, 0, 0, 0, 643, 647, 5, 15, 0, 0, 644,
		646, 3, 96, 48, 0, 645, 644, 1, 0, 0, 0, 646, 649, 1, 0, 0, 0, 647, 645,
		1, 0, 0, 0, 647, 648, 1, 0, 0, 0, 648, 650, 1, 0, 0, 0, 649, 647, 1, 0,
		0, 0, 650, 651, 5, 17, 0, 0, 651, 95, 1, 0, 0, 0, 652, 668, 3, 100, 50,
		0, 653, 668, 3, 102, 51, 0, 654, 668, 3, 106, 53, 0, 655, 668, 3, 112,
		56, 0, 656, 668, 3, 94, 47, 0, 657, 668, 3, 114, 57, 0, 658, 668, 3, 118,
		59, 0, 659, 668, 3, 120, 60, 0, 660, 668, 3, 122, 61, 0, 661, 668, 3, 124,
		62, 0, 662, 668, 3, 126, 63, 0, 663, 668, 3, 128, 64, 0, 664, 668, 3, 108,
		54, 0, 665, 668, 3, 110, 55, 0, 666, 668, 3, 130, 65, 0, 667, 652, 1, 0,
		0, 0, 667, 653, 1, 0, 0, 0, 667, 654, 1, 0, 0, 0, 667, 655, 1, 0, 0, 0,
		667, 656, 1, 0, 0, 0, 667, 657, 1, 0, 0, 0, 667, 658, 1, 0, 0, 0, 667,
		659, 1, 0, 0, 0, 667, 660, 1, 0, 0, 0, 667, 661, 1, 0, 0, 0, 667, 662,
		1, 0, 0, 0, 667, 663, 1, 0, 0, 0, 667, 664, 1, 0, 0, 0, 667, 665, 1, 0,
		0, 0, 667, 666, 1, 0, 0, 0, 668, 97, 1, 0, 0, 0, 669, 670, 3, 140, 70,
		0, 670, 671, 5, 2, 0, 0, 671, 99, 1, 0, 0, 0, 672, 673, 5, 51, 0, 0, 673,
		674, 5, 23, 0, 0, 674, 675, 3, 140, 70, 0, 675, 676, 5, 24, 0, 0, 676,
		679, 3, 96, 48, 0, 677, 678, 5, 52, 0, 0, 678, 680, 3, 96, 48, 0, 679,
		677, 1, 0, 0, 0, 679, 680, 1, 0, 0, 0, 680, 101, 1, 0, 0, 0, 681, 682,
		5, 53, 0, 0, 682, 684, 3, 140, 70, 0, 683, 685, 3, 52, 26, 0, 684, 683,
		1, 0, 0, 0, 684, 685, 1, 0, 0, 0, 685, 686, 1, 0, 0, 0, 686, 688, 3, 94,
		47, 0, 687, 689, 3, 104, 52, 0, 688, 687, 1, 0, 0, 0, 689, 690, 1, 0, 0,
		0, 690, 688, 1, 0, 0, 0, 690, 691, 1, 0, 0, 0, 691, 103, 1, 0, 0, 0, 692,
		697, 5, 54, 0, 0, 693, 695, 3, 194, 97, 0, 694, 693, 1, 0, 0, 0, 694, 695,
		1, 0, 0, 0, 695, 696, 1, 0, 0, 0, 696, 698, 3, 62, 31, 0, 697, 694, 1,
		0, 0, 0, 697, 698, 1, 0, 0, 0, 698, 699, 1, 0, 0, 0, 699, 700, 3, 94, 47,
		0, 700, 105, 1, 0, 0, 0, 701, 702, 5, 55, 0, 0, 702, 703, 5, 23, 0, 0,
		703, 704, 3, 140, 70, 0, 704, 705, 5, 24, 0, 0, 705, 706, 3, 96, 48, 0,
		706, 107, 1, 0, 0, 0, 707, 710, 3, 132, 66, 0, 708, 710, 3, 98, 49, 0,
		709, 707, 1, 0, 0, 0, 709, 708, 1, 0, 0, 0, 710, 109, 1, 0, 0, 0, 711,
		712, 5, 56, 0, 0, 712, 713, 3, 94, 47, 0, 713, 111, 1, 0, 0, 0, 714, 715,
		5, 27, 0, 0, 715, 718, 5, 23, 0, 0, 716, 719, 3, 108, 54, 0, 717, 719,
		5, 2, 0, 0, 718, 716, 1, 0, 0, 0, 718, 717, 1, 0, 0, 0, 719, 722, 1, 0,
		0, 0, 720, 723, 3, 98, 49, 0, 721, 723, 5, 2, 0, 0, 722, 720, 1, 0, 0,
		0, 722, 721, 1, 0, 0, 0, 723, 725, 1, 0, 0, 0, 724, 726, 3, 140, 70, 0,
		725, 724, 1, 0, 0, 0, 725, 726, 1, 0, 0, 0, 726, 727, 1, 0, 0, 0, 727,
		728, 5, 24, 0, 0, 728, 729, 3, 96, 48, 0, 729, 113, 1, 0, 0, 0, 730, 732,
		5, 57, 0, 0, 731, 733, 5, 129, 0, 0, 732, 731, 1, 0, 0, 0, 732, 733, 1,
		0, 0, 0, 733, 738, 1, 0, 0, 0, 734, 735, 5, 23, 0, 0, 735, 736, 3, 116,
		58, 0, 736, 737, 5, 24, 0, 0, 737, 739, 1, 0, 0, 0, 738, 734, 1, 0, 0,
		0, 738, 739, 1, 0, 0, 0, 739, 740, 1, 0, 0, 0, 740, 741, 3, 154, 77, 0,
		741, 115, 1, 0, 0, 0, 742, 743, 3, 200, 100, 0, 743, 117, 1, 0, 0, 0, 744,
		745, 5, 58, 0, 0, 745, 746, 3, 96, 48, 0, 746, 747, 5, 55, 0, 0, 747, 748,
		5, 23, 0, 0, 748, 749, 3, 140, 70, 0, 749, 750, 5, 24, 0, 0, 750, 751,
		5, 2, 0, 0, 751, 119, 1, 0, 0, 0, 752, 753, 5, 112, 0, 0, 753, 754, 5,
		2, 0, 0, 754, 121, 1, 0, 0, 0, 755, 756, 5, 109, 0, 0, 756, 757, 5, 2,
		0, 0, 757, 123, 1, 0, 0, 0, 758, 760, 5, 59, 0, 0, 759, 761, 3, 140, 70,
		0, 760, 759, 1, 0, 0, 0, 760, 761, 1, 0, 0, 0, 761, 762, 1, 0, 0, 0, 762,
		763, 5, 2, 0, 0, 763, 125, 1, 0, 0, 0, 764, 765, 5, 60, 0, 0, 765, 766,
		5, 2, 0, 0, 766, 127, 1, 0, 0, 0, 767, 768, 5, 61, 0, 0, 768, 769, 3, 152,
		76, 0, 769, 770, 5, 2, 0, 0, 770, 129, 1, 0, 0, 0, 771, 772, 5, 62, 0,
		0, 772, 773, 3, 152, 76, 0, 773, 774, 5, 2, 0, 0, 774, 131, 1, 0, 0, 0,
		775, 776, 5, 63, 0, 0, 776, 783, 3, 136, 68, 0, 777, 783, 3, 74, 37, 0,
		778, 779, 5, 23, 0, 0, 779, 780, 3, 134, 67, 0, 780, 781, 5, 24, 0, 0,
		781, 783, 1, 0, 0, 0, 782, 775, 1, 0, 0, 0, 782, 777, 1, 0, 0, 0, 782,
		778, 1, 0, 0, 0, 783, 786, 1, 0, 0, 0, 784, 785, 5, 11, 0, 0, 785, 787,
		3, 140, 70, 0, 786, 784, 1, 0, 0, 0, 786, 787, 1, 0, 0, 0, 787, 788, 1,
		0, 0, 0, 788, 789, 5, 2, 0, 0, 789, 133, 1, 0, 0, 0, 790, 792, 3, 74, 37,
		0, 791, 790, 1, 0, 0, 0, 791, 792, 1, 0, 0, 0, 792, 799, 1, 0, 0, 0, 793,
		795, 5, 16, 0, 0, 794, 796, 3, 74, 37, 0, 795, 794, 1, 0, 0, 0, 795, 796,
		1, 0, 0, 0, 796, 798, 1, 0, 0, 0, 797, 793, 1, 0, 0, 0, 798, 801, 1, 0,
		0, 0, 799, 797, 1, 0, 0, 0, 799, 800, 1, 0, 0, 0, 800, 135, 1, 0, 0, 0,
		801, 799, 1, 0, 0, 0, 802, 809, 5, 23, 0, 0, 803, 805, 3, 194, 97, 0, 804,
		803, 1, 0, 0, 0, 804, 805, 1, 0, 0, 0, 805, 806, 1, 0, 0, 0, 806, 808,
		5, 16, 0, 0, 807, 804, 1, 0, 0, 0, 808, 811, 1, 0, 0, 0, 809, 807, 1, 0,
		0, 0, 809, 810, 1, 0, 0, 0, 810, 813, 1, 0, 0, 0, 811, 809, 1, 0, 0, 0,
		812, 814, 3, 194, 97, 0, 813, 812, 1, 0, 0, 0, 813, 814, 1, 0, 0, 0, 814,
		815, 1, 0, 0, 0, 815, 816, 5, 24, 0, 0, 816, 137, 1, 0, 0, 0, 817, 818,
		7, 5, 0, 0, 818, 139, 1, 0, 0, 0, 819, 820, 6, 70, -1, 0, 820, 821, 5,
		69, 0, 0, 821, 838, 3, 76, 38, 0, 822, 823, 5, 23, 0, 0, 823, 824, 3, 140,
		70, 0, 824, 825, 5, 24, 0, 0, 825, 838, 1, 0, 0, 0, 826, 827, 7, 6, 0,
		0, 827, 838, 3, 140, 70, 19, 828, 829, 7, 7, 0, 0, 829, 838, 3, 140, 70,
		18, 830, 831, 5, 71, 0, 0, 831, 838, 3, 140, 70, 17, 832, 833, 5, 72, 0,
		0, 833, 838, 3, 140, 70, 16, 834, 835, 5, 6, 0, 0, 835, 838, 3, 140, 70,
		15, 836, 838, 3, 142, 71, 0, 837, 819, 1, 0, 0, 0, 837, 822, 1, 0, 0, 0,
		837, 826, 1, 0, 0, 0, 837, 828, 1, 0, 0, 0, 837, 830, 1, 0, 0, 0, 837,
		832, 1, 0, 0, 0, 837, 834, 1, 0, 0, 0, 837, 836, 1, 0, 0, 0, 838, 913,
		1, 0, 0, 0, 839, 840, 10, 14, 0, 0, 840, 841, 5, 73, 0, 0, 841, 912, 3,
		140, 70, 15, 842, 843, 10, 13, 0, 0, 843, 844, 7, 8, 0, 0, 844, 912, 3,
		140, 70, 14, 845, 846, 10, 12, 0, 0, 846, 847, 7, 7, 0, 0, 847, 912, 3,
		140, 70, 13, 848, 849, 10, 11, 0, 0, 849, 850, 7, 9, 0, 0, 850, 912, 3,
		140, 70, 12, 851, 852, 10, 10, 0, 0, 852, 853, 5, 29, 0, 0, 853, 912, 3,
		140, 70, 11, 854, 855, 10, 9, 0, 0, 855, 856, 5, 5, 0, 0, 856, 912, 3,
		140, 70, 10, 857, 858, 10, 8, 0, 0, 858, 859, 5, 28, 0, 0, 859, 912, 3,
		140, 70, 9, 860, 861, 10, 7, 0, 0, 861, 862, 7, 10, 0, 0, 862, 912, 3,
		140, 70, 8, 863, 864, 10, 6, 0, 0, 864, 865, 7, 11, 0, 0, 865, 912, 3,
		140, 70, 7, 866, 867, 10, 5, 0, 0, 867, 868, 5, 76, 0, 0, 868, 912, 3,
		140, 70, 6, 869, 870, 10, 4, 0, 0, 870, 871, 5, 4, 0, 0, 871, 912, 3, 140,
		70, 5, 872, 873, 10, 3, 0, 0, 873, 874, 5, 77, 0, 0, 874, 875, 3, 140,
		70, 0, 875, 876, 5, 70, 0, 0, 876, 877, 3, 140, 70, 4, 877, 912, 1, 0,
		0, 0, 878, 879, 10, 2, 0, 0, 879, 880, 7, 12, 0, 0, 880, 912, 3, 140, 70,
		3, 881, 882, 10, 27, 0, 0, 882, 912, 7, 6, 0, 0, 883, 884, 10, 25, 0, 0,
		884, 885, 5, 42, 0, 0, 885, 886, 3, 140, 70, 0, 886, 887, 5, 43, 0, 0,
		887, 912, 1, 0, 0, 0, 888, 889, 10, 24, 0, 0, 889, 891, 5, 42, 0, 0, 890,
		892, 3, 140, 70, 0, 891, 890, 1, 0, 0, 0, 891, 892, 1, 0, 0, 0, 892, 893,
		1, 0, 0, 0, 893, 895, 5, 70, 0, 0, 894, 896, 3, 140, 70, 0, 895, 894, 1,
		0, 0, 0, 895, 896, 1, 0, 0, 0, 896, 897, 1, 0, 0, 0, 897, 912, 5, 43, 0,
		0, 898, 899, 10, 23, 0, 0, 899, 900, 5, 45, 0, 0, 900, 912, 3, 194, 97,
		0, 901, 902, 10, 22, 0, 0, 902, 903, 5, 15, 0, 0, 903, 904, 3, 146, 73,
		0, 904, 905, 5, 17, 0, 0, 905, 912, 1, 0, 0, 0, 906, 907, 10, 21, 0, 0,
		907, 908, 5, 23, 0, 0, 908, 909, 3, 150, 75, 0, 909, 910, 5, 24, 0, 0,
		910, 912, 1, 0, 0, 0, 911, 839, 1, 0, 0, 0, 911, 842, 1, 0, 0, 0, 911,
		845, 1, 0, 0, 0, 911, 848, 1, 0, 0, 0, 911, 851, 1, 0, 0, 0, 911, 854,
		1, 0, 0, 0, 911, 857, 1, 0, 0, 0, 911, 860, 1, 0, 0, 0, 911, 863, 1, 0,
		0, 0, 911, 866, 1, 0, 0, 0, 911, 869, 1, 0, 0, 0, 911, 872, 1, 0, 0, 0,
		911, 878, 1, 0, 0, 0, 911, 881, 1, 0, 0, 0, 911, 883, 1, 0, 0, 0, 911,
		888, 1, 0, 0, 0, 911, 898, 1, 0, 0, 0, 911, 901, 1, 0, 0, 0, 911, 906,
		1, 0, 0, 0, 912, 915, 1, 0, 0, 0, 913, 911, 1, 0, 0, 0, 913, 914, 1, 0,
		0, 0, 914, 141, 1, 0, 0, 0, 915, 913, 1, 0, 0, 0, 916, 926, 5, 102, 0,
		0, 917, 926, 3, 192, 96, 0, 918, 926, 3, 196, 98, 0, 919, 926, 3, 200,
		100, 0, 920, 926, 3, 194, 97, 0, 921, 926, 5, 122, 0, 0, 922, 926, 5, 117,
		0, 0, 923, 926, 3, 190, 95, 0, 924, 926, 3, 76, 38, 0, 925, 916, 1, 0,
		0, 0, 925, 917, 1, 0, 0, 0, 925, 918, 1, 0, 0, 0, 925, 919, 1, 0, 0, 0,
		925, 920, 1, 0, 0, 0, 925, 921, 1, 0, 0, 0, 925, 922, 1, 0, 0, 0, 925,
		923, 1, 0, 0, 0, 925, 924, 1, 0, 0, 0, 926, 143, 1, 0, 0, 0, 927, 932,
		3, 140, 70, 0, 928, 929, 5, 16, 0, 0, 929, 931, 3, 140, 70, 0, 930, 928,
		1, 0, 0, 0, 931, 934, 1, 0, 0, 0, 932, 930, 1, 0, 0, 0, 932, 933, 1, 0,
		0, 0, 933, 145, 1, 0, 0, 0, 934, 932, 1, 0, 0, 0, 935, 940, 3, 148, 74,
		0, 936, 937, 5, 16, 0, 0, 937, 939, 3, 148, 74, 0, 938, 936, 1, 0, 0, 0,
		939, 942, 1, 0, 0, 0, 940, 938, 1, 0, 0, 0, 940, 941, 1, 0, 0, 0, 941,
		944, 1, 0, 0, 0, 942, 940, 1, 0, 0, 0, 943, 945, 5, 16, 0, 0, 944, 943,
		1, 0, 0, 0, 944, 945, 1, 0, 0, 0, 945, 147, 1, 0, 0, 0, 946, 947, 3, 194,
		97, 0, 947, 948, 5, 70, 0, 0, 948, 949, 3, 140, 70, 0, 949, 149, 1, 0,
		0, 0, 950, 952, 5, 15, 0, 0, 951, 953, 3, 146, 73, 0, 952, 951, 1, 0, 0,
		0, 952, 953, 1, 0, 0, 0, 953, 954, 1, 0, 0, 0, 954, 959, 5, 17, 0, 0, 955,
		957, 3, 144, 72, 0, 956, 955, 1, 0, 0, 0, 956, 957, 1, 0, 0, 0, 957, 959,
		1, 0, 0, 0, 958, 950, 1, 0, 0, 0, 958, 956, 1, 0, 0, 0, 959, 151, 1, 0,
		0, 0, 960, 961, 3, 140, 70, 0, 961, 962, 5, 23, 0, 0, 962, 963, 3, 150,
		75, 0, 963, 964, 5, 24, 0, 0, 964, 153, 1, 0, 0, 0, 965, 969, 5, 15, 0,
		0, 966, 968, 3, 156, 78, 0, 967, 966, 1, 0, 0, 0, 968, 971, 1, 0, 0, 0,
		969, 967, 1, 0, 0, 0, 969, 970, 1, 0, 0, 0, 970, 972, 1, 0, 0, 0, 971,
		969, 1, 0, 0, 0, 972, 973, 5, 17, 0, 0, 973, 155, 1, 0, 0, 0, 974, 992,
		3, 194, 97, 0, 975, 992, 3, 154, 77, 0, 976, 992, 3, 158, 79, 0, 977, 992,
		3, 164, 82, 0, 978, 992, 3, 166, 83, 0, 979, 992, 3, 172, 86, 0, 980, 992,
		3, 174, 87, 0, 981, 992, 3, 176, 88, 0, 982, 992, 3, 180, 90, 0, 983, 992,
		3, 184, 92, 0, 984, 992, 3, 186, 93, 0, 985, 992, 5, 109, 0, 0, 986, 992,
		5, 112, 0, 0, 987, 992, 5, 113, 0, 0, 988, 992, 3, 192, 96, 0, 989, 992,
		3, 200, 100, 0, 990, 992, 3, 196, 98, 0, 991, 974, 1, 0, 0, 0, 991, 975,
		1, 0, 0, 0, 991, 976, 1, 0, 0, 0, 991, 977, 1, 0, 0, 0, 991, 978, 1, 0,
		0, 0, 991, 979, 1, 0, 0, 0, 991, 980, 1, 0, 0, 0, 991, 981, 1, 0, 0, 0,
		991, 982, 1, 0, 0, 0, 991, 983, 1, 0, 0, 0, 991, 984, 1, 0, 0, 0, 991,
		985, 1, 0, 0, 0, 991, 986, 1, 0, 0, 0, 991, 987, 1, 0, 0, 0, 991, 988,
		1, 0, 0, 0, 991, 989, 1, 0, 0, 0, 991, 990, 1, 0, 0, 0, 992, 157, 1, 0,
		0, 0, 993, 997, 3, 162, 81, 0, 994, 997, 3, 188, 94, 0, 995, 997, 3, 160,
		80, 0, 996, 993, 1, 0, 0, 0, 996, 994, 1, 0, 0, 0, 996, 995, 1, 0, 0, 0,
		997, 159, 1, 0, 0, 0, 998, 999, 3, 194, 97, 0, 999, 1000, 5, 45, 0, 0,
		1000, 1001, 3, 194, 97, 0, 1001, 161, 1, 0, 0, 0, 1002, 1007, 5, 59, 0,
		0, 1003, 1007, 5, 44, 0, 0, 1004, 1007, 5, 66, 0, 0, 1005, 1007, 3, 194,
		97, 0, 1006, 1002, 1, 0, 0, 0, 1006, 1003, 1, 0, 0, 0, 1006, 1004, 1, 0,
		0, 0, 1006, 1005, 1, 0, 0, 0, 1007, 1020, 1, 0, 0, 0, 1008, 1010, 5, 23,
		0, 0, 1009, 1011, 3, 158, 79, 0, 1010, 1009, 1, 0, 0, 0, 1010, 1011, 1,
		0, 0, 0, 1011, 1016, 1, 0, 0, 0, 1012, 1013, 5, 16, 0, 0, 1013, 1015, 3,
		158, 79, 0, 1014, 1012, 1, 0, 0, 0, 1015, 1018, 1, 0, 0, 0, 1016, 1014,
		1, 0, 0, 0, 1016, 1017, 1, 0, 0, 0, 1017, 1019, 1, 0, 0, 0, 1018, 1016,
		1, 0, 0, 0, 1019, 1021, 5, 24, 0, 0, 1020, 1008, 1, 0, 0, 0, 1020, 1021,
		1, 0, 0, 0, 1021, 163, 1, 0, 0, 0, 1022, 1023, 5, 88, 0, 0, 1023, 1026,
		3, 168, 84, 0, 1024, 1025, 5, 89, 0, 0, 1025, 1027, 3, 158, 79, 0, 1026,
		1024, 1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027, 165, 1, 0, 0, 0, 1028,
		1029, 3, 168, 84, 0, 1029, 1030, 5, 89, 0, 0, 1030, 1031, 3, 158, 79, 0,
		1031, 167, 1, 0, 0, 0, 1032, 1040, 3, 194, 97, 0, 1033, 1040, 3, 160, 80,
		0, 1034, 1040, 3, 170, 85, 0, 1035, 1036, 5, 23, 0, 0, 1036, 1037, 3, 170,
		85, 0, 1037, 1038, 5, 24, 0, 0, 1038, 1040, 1, 0, 0, 0, 1039, 1032, 1,
		0, 0, 0, 1039, 1033, 1, 0, 0, 0, 1039, 1034, 1, 0, 0, 0, 1039, 1035, 1,
		0, 0, 0, 1040, 169, 1, 0, 0, 0, 1041, 1046, 3, 194, 97, 0, 1042, 1043,
		5, 16, 0, 0, 1043, 1045, 3, 194, 97, 0, 1044, 1042, 1, 0, 0, 0, 1045, 1048,
		1, 0, 0, 0, 1046, 1044, 1, 0, 0, 0, 1046, 1047, 1, 0, 0, 0, 1047, 171,
		1, 0, 0, 0, 1048, 1046, 1, 0, 0, 0, 1049, 1050, 3, 158, 79, 0, 1050, 1051,
		5, 90, 0, 0, 1051, 1052, 3, 194, 97, 0, 1052, 173, 1, 0, 0, 0, 1053, 1054,
		3, 194, 97, 0, 1054, 1055, 5, 70, 0, 0, 1055, 175, 1, 0, 0, 0, 1056, 1057,
		5, 91, 0, 0, 1057, 1061, 3, 158, 79, 0, 1058, 1060, 3, 178, 89, 0, 1059,
		1058, 1, 0, 0, 0, 1060, 1063, 1, 0, 0, 0, 1061, 1059, 1, 0, 0, 0, 1061,
		1062, 1, 0, 0, 0, 1062, 177, 1, 0, 0, 0, 1063, 1061, 1, 0, 0, 0, 1064,
		1065, 5, 92, 0, 0, 1065, 1066, 3, 188, 94, 0, 1066, 1067, 3, 154, 77, 0,
		1067, 1071, 1, 0, 0, 0, 1068, 1069, 5, 93, 0, 0, 1069, 1071, 3, 154, 77,
		0, 1070, 1064, 1, 0, 0, 0, 1070, 1068, 1, 0, 0, 0, 1071, 179, 1, 0, 0,
		0, 1072, 1073, 5, 38, 0, 0, 1073, 1074, 3, 194, 97, 0, 1074, 1076, 5, 23,
		0, 0, 1075, 1077, 3, 170, 85, 0, 1076, 1075, 1, 0, 0, 0, 1076, 1077, 1,
		0, 0, 0, 1077, 1078, 1, 0, 0, 0, 1078, 1080, 5, 24, 0, 0, 1079, 1081, 3,
		182, 91, 0, 1080, 1079, 1, 0, 0, 0, 1080, 1081, 1, 0, 0, 0, 1081, 1082,
		1, 0, 0, 0, 1082, 1083, 3, 154, 77, 0, 1083, 181, 1, 0, 0, 0, 1084, 1085,
		5, 94, 0, 0, 1085, 1086, 3, 170, 85, 0, 1086, 183, 1, 0, 0, 0, 1087, 1090,
		5, 27, 0, 0, 1088, 1091, 3, 154, 77, 0, 1089, 1091, 3, 158, 79, 0, 1090,
		1088, 1, 0, 0, 0, 1090, 1089, 1, 0, 0, 0, 1091, 1092, 1, 0, 0, 0, 1092,
		1095, 3, 158, 79, 0, 1093, 1096, 3, 154, 77, 0, 1094, 1096, 3, 158, 79,
		0, 1095, 1093, 1, 0, 0, 0, 1095, 1094, 1, 0, 0, 0, 1096, 1097, 1, 0, 0,
		0, 1097, 1098, 3, 154, 77, 0, 1098, 185, 1, 0, 0, 0, 1099, 1100, 5, 51,
		0, 0, 1100, 1101, 3, 158, 79, 0, 1101, 1102, 3, 154, 77, 0, 1102, 187,
		1, 0, 0, 0, 1103, 1109, 3, 200, 100, 0, 1104, 1109, 5, 103, 0, 0, 1105,
		1109, 5, 104, 0, 0, 1106, 1109, 3, 196, 98, 0, 1107, 1109, 5, 102, 0, 0,
		1108, 1103, 1, 0, 0, 0, 1108, 1104, 1, 0, 0, 0, 1108, 1105, 1, 0, 0, 0,
		1108, 1106, 1, 0, 0, 0, 1108, 1107, 1, 0, 0, 0, 1109, 189, 1, 0, 0, 0,
		1110, 1112, 5, 23, 0, 0, 1111, 1113, 3, 140, 70, 0, 1112, 1111, 1, 0, 0,
		0, 1112, 1113, 1, 0, 0, 0, 1113, 1120, 1, 0, 0, 0, 1114, 1116, 5, 16, 0,
		0, 1115, 1117, 3, 140, 70, 0, 1116, 1115, 1, 0, 0, 0, 1116, 1117, 1, 0,
		0, 0, 1117, 1119, 1, 0, 0, 0, 1118, 1114, 1, 0, 0, 0, 1119, 1122, 1, 0,
		0, 0, 1120, 1118, 1, 0, 0, 0, 1120, 1121, 1, 0, 0, 0, 1121, 1123, 1, 0,
		0, 0, 1122, 1120, 1, 0, 0, 0, 1123, 1137, 5, 24, 0, 0, 1124, 1133, 5, 42,
		0, 0, 1125, 1130, 3, 140, 70, 0, 1126, 1127, 5, 16, 0, 0, 1127, 1129, 3,
		140, 70, 0, 1128, 1126, 1, 0, 0, 0, 1129, 1132, 1, 0, 0, 0, 1130, 1128,
		1, 0, 0, 0, 1130, 1131, 1, 0, 0, 0, 1131, 1134, 1, 0, 0, 0, 1132, 1130,
		1, 0, 0, 0, 1133, 1125, 1, 0, 0, 0, 1133, 1134, 1, 0, 0, 0, 1134, 1135,
		1, 0, 0, 0, 1135, 1137, 5, 43, 0, 0, 1136, 1110, 1, 0, 0, 0, 1136, 1124,
		1, 0, 0, 0, 1137, 191, 1, 0, 0, 0, 1138, 1140, 7, 13, 0, 0, 1139, 1141,
		5, 105, 0, 0, 1140, 1139, 1, 0, 0, 0, 1140, 1141, 1, 0, 0, 0, 1141, 193,
		1, 0, 0, 0, 1142, 1143, 7, 14, 0, 0, 1143, 195, 1, 0, 0, 0, 1144, 1146,
		5, 106, 0, 0, 1145, 1144, 1, 0, 0, 0, 1146, 1147, 1, 0, 0, 0, 1147, 1145,
		1, 0, 0, 0, 1147, 1148, 1, 0, 0, 0, 1148, 197, 1, 0, 0, 0, 1149, 1161,
		5, 96, 0, 0, 1150, 1151, 5, 23, 0, 0, 1151, 1156, 3, 78, 39, 0, 1152, 1153,
		5, 16, 0, 0, 1153, 1155, 3, 78, 39, 0, 1154, 1152, 1, 0, 0, 0, 1155, 1158,
		1, 0, 0, 0, 1156, 1154, 1, 0, 0, 0, 1156, 1157, 1, 0, 0, 0, 1157, 1159,
		1, 0, 0, 0, 1158, 1156, 1, 0, 0, 0, 1159, 1160, 5, 24, 0, 0, 1160, 1162,
		1, 0, 0, 0, 1161, 1150, 1, 0, 0, 0, 1161, 1162, 1, 0, 0, 0, 1162, 199,
		1, 0, 0, 0, 1163, 1165, 5, 129, 0, 0, 1164, 1163, 1, 0, 0, 0, 1165, 1166,
		1, 0, 0, 0, 1166, 1164, 1, 0, 0, 0, 1166, 1167, 1, 0, 0, 0, 1167, 201,
		1, 0, 0, 0, 130, 212, 214, 229, 233, 238, 244, 248, 251, 256, 262, 269,
		273, 286, 294, 299, 309, 312, 318, 326, 329, 340, 349, 351, 357, 384, 387,
		398, 403, 408, 422, 425, 432, 436, 438, 443, 448, 451, 457, 461, 465, 470,
		483, 485, 492, 502, 508, 519, 522, 528, 531, 539, 542, 548, 551, 559, 562,
		568, 572, 583, 588, 593, 601, 606, 612, 617, 630, 632, 637, 647, 667, 679,
		684, 690, 694, 697, 709, 718, 722, 725, 732, 738, 760, 782, 786, 791, 795,
		799, 804, 809, 813, 837, 891, 895, 911, 913, 925, 932, 940, 944, 952, 956,
		958, 969, 991, 996, 1006, 1010, 1016, 1020, 1026, 1039, 1046, 1061, 1070,
		1076, 1080, 1090, 1095, 1108, 1112, 1116, 1120, 1130, 1133, 1136, 1140,
		1147, 1156, 1161, 1166,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// SolidityParserInit initializes any static state used to implement SolidityParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewSolidityParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func SolidityParserInit() {
	staticData := &solidityParserStaticData
	staticData.once.Do(solidityParserInit)
}

// NewSolidityParser produces a new parser instance for the optional input antlr.TokenStream.
func NewSolidityParser(input antlr.TokenStream) *SolidityParser {
	SolidityParserInit()
	this := new(SolidityParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &solidityParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "Solidity.g4"

	return this
}

// SolidityParser tokens.
const (
	SolidityParserEOF                   = antlr.TokenEOF
	SolidityParserT__0                  = 1
	SolidityParserT__1                  = 2
	SolidityParserT__2                  = 3
	SolidityParserT__3                  = 4
	SolidityParserT__4                  = 5
	SolidityParserT__5                  = 6
	SolidityParserT__6                  = 7
	SolidityParserT__7                  = 8
	SolidityParserT__8                  = 9
	SolidityParserT__9                  = 10
	SolidityParserT__10                 = 11
	SolidityParserT__11                 = 12
	SolidityParserT__12                 = 13
	SolidityParserT__13                 = 14
	SolidityParserT__14                 = 15
	SolidityParserT__15                 = 16
	SolidityParserT__16                 = 17
	SolidityParserT__17                 = 18
	SolidityParserT__18                 = 19
	SolidityParserT__19                 = 20
	SolidityParserT__20                 = 21
	SolidityParserT__21                 = 22
	SolidityParserT__22                 = 23
	SolidityParserT__23                 = 24
	SolidityParserT__24                 = 25
	SolidityParserT__25                 = 26
	SolidityParserT__26                 = 27
	SolidityParserT__27                 = 28
	SolidityParserT__28                 = 29
	SolidityParserT__29                 = 30
	SolidityParserT__30                 = 31
	SolidityParserT__31                 = 32
	SolidityParserT__32                 = 33
	SolidityParserT__33                 = 34
	SolidityParserT__34                 = 35
	SolidityParserT__35                 = 36
	SolidityParserT__36                 = 37
	SolidityParserT__37                 = 38
	SolidityParserT__38                 = 39
	SolidityParserT__39                 = 40
	SolidityParserT__40                 = 41
	SolidityParserT__41                 = 42
	SolidityParserT__42                 = 43
	SolidityParserT__43                 = 44
	SolidityParserT__44                 = 45
	SolidityParserT__45                 = 46
	SolidityParserT__46                 = 47
	SolidityParserT__47                 = 48
	SolidityParserT__48                 = 49
	SolidityParserT__49                 = 50
	SolidityParserT__50                 = 51
	SolidityParserT__51                 = 52
	SolidityParserT__52                 = 53
	SolidityParserT__53                 = 54
	SolidityParserT__54                 = 55
	SolidityParserT__55                 = 56
	SolidityParserT__56                 = 57
	SolidityParserT__57                 = 58
	SolidityParserT__58                 = 59
	SolidityParserT__59                 = 60
	SolidityParserT__60                 = 61
	SolidityParserT__61                 = 62
	SolidityParserT__62                 = 63
	SolidityParserT__63                 = 64
	SolidityParserT__64                 = 65
	SolidityParserT__65                 = 66
	SolidityParserT__66                 = 67
	SolidityParserT__67                 = 68
	SolidityParserT__68                 = 69
	SolidityParserT__69                 = 70
	SolidityParserT__70                 = 71
	SolidityParserT__71                 = 72
	SolidityParserT__72                 = 73
	SolidityParserT__73                 = 74
	SolidityParserT__74                 = 75
	SolidityParserT__75                 = 76
	SolidityParserT__76                 = 77
	SolidityParserT__77                 = 78
	SolidityParserT__78                 = 79
	SolidityParserT__79                 = 80
	SolidityParserT__80                 = 81
	SolidityParserT__81                 = 82
	SolidityParserT__82                 = 83
	SolidityParserT__83                 = 84
	SolidityParserT__84                 = 85
	SolidityParserT__85                 = 86
	SolidityParserT__86                 = 87
	SolidityParserT__87                 = 88
	SolidityParserT__88                 = 89
	SolidityParserT__89                 = 90
	SolidityParserT__90                 = 91
	SolidityParserT__91                 = 92
	SolidityParserT__92                 = 93
	SolidityParserT__93                 = 94
	SolidityParserT__94                 = 95
	SolidityParserT__95                 = 96
	SolidityParserInt                   = 97
	SolidityParserUint                  = 98
	SolidityParserByte                  = 99
	SolidityParserFixed                 = 100
	SolidityParserUfixed                = 101
	SolidityParserBooleanLiteral        = 102
	SolidityParserDecimalNumber         = 103
	SolidityParserHexNumber             = 104
	SolidityParserNumberUnit            = 105
	SolidityParserHexLiteralFragment    = 106
	SolidityParserReservedKeyword       = 107
	SolidityParserAnonymousKeyword      = 108
	SolidityParserBreakKeyword          = 109
	SolidityParserConstantKeyword       = 110
	SolidityParserImmutableKeyword      = 111
	SolidityParserContinueKeyword       = 112
	SolidityParserLeaveKeyword          = 113
	SolidityParserExternalKeyword       = 114
	SolidityParserIndexedKeyword        = 115
	SolidityParserInternalKeyword       = 116
	SolidityParserPayableKeyword        = 117
	SolidityParserPrivateKeyword        = 118
	SolidityParserPublicKeyword         = 119
	SolidityParserVirtualKeyword        = 120
	SolidityParserPureKeyword           = 121
	SolidityParserTypeKeyword           = 122
	SolidityParserViewKeyword           = 123
	SolidityParserGlobalKeyword         = 124
	SolidityParserConstructorKeyword    = 125
	SolidityParserFallbackKeyword       = 126
	SolidityParserReceiveKeyword        = 127
	SolidityParserIdentifier            = 128
	SolidityParserStringLiteralFragment = 129
	SolidityParserVersionLiteral        = 130
	SolidityParserWS                    = 131
	SolidityParserCOMMENT               = 132
	SolidityParserLINE_COMMENT          = 133
)

// SolidityParser rules.
const (
	SolidityParserRULE_sourceUnit                   = 0
	SolidityParserRULE_pragmaDirective              = 1
	SolidityParserRULE_pragmaName                   = 2
	SolidityParserRULE_pragmaValue                  = 3
	SolidityParserRULE_version                      = 4
	SolidityParserRULE_versionOperator              = 5
	SolidityParserRULE_versionConstraint            = 6
	SolidityParserRULE_importDeclaration            = 7
	SolidityParserRULE_importDirective              = 8
	SolidityParserRULE_importPath                   = 9
	SolidityParserRULE_contractDefinition           = 10
	SolidityParserRULE_inheritanceSpecifier         = 11
	SolidityParserRULE_contractPart                 = 12
	SolidityParserRULE_stateVariableDeclaration     = 13
	SolidityParserRULE_fileLevelConstant            = 14
	SolidityParserRULE_customErrorDefinition        = 15
	SolidityParserRULE_typeDefinition               = 16
	SolidityParserRULE_usingForDeclaration          = 17
	SolidityParserRULE_usingForObject               = 18
	SolidityParserRULE_usingForObjectDirective      = 19
	SolidityParserRULE_userDefinableOperators       = 20
	SolidityParserRULE_structDefinition             = 21
	SolidityParserRULE_modifierDefinition           = 22
	SolidityParserRULE_modifierInvocation           = 23
	SolidityParserRULE_functionDefinition           = 24
	SolidityParserRULE_functionDescriptor           = 25
	SolidityParserRULE_returnParameters             = 26
	SolidityParserRULE_modifierList                 = 27
	SolidityParserRULE_eventDefinition              = 28
	SolidityParserRULE_enumValue                    = 29
	SolidityParserRULE_enumDefinition               = 30
	SolidityParserRULE_parameterList                = 31
	SolidityParserRULE_parameter                    = 32
	SolidityParserRULE_eventParameterList           = 33
	SolidityParserRULE_eventParameter               = 34
	SolidityParserRULE_functionTypeParameterList    = 35
	SolidityParserRULE_functionTypeParameter        = 36
	SolidityParserRULE_variableDeclaration          = 37
	SolidityParserRULE_typeName                     = 38
	SolidityParserRULE_userDefinedTypeName          = 39
	SolidityParserRULE_mappingKey                   = 40
	SolidityParserRULE_mapping                      = 41
	SolidityParserRULE_mappingKeyName               = 42
	SolidityParserRULE_mappingValueName             = 43
	SolidityParserRULE_functionTypeName             = 44
	SolidityParserRULE_storageLocation              = 45
	SolidityParserRULE_stateMutability              = 46
	SolidityParserRULE_block                        = 47
	SolidityParserRULE_statement                    = 48
	SolidityParserRULE_expressionStatement          = 49
	SolidityParserRULE_ifStatement                  = 50
	SolidityParserRULE_tryStatement                 = 51
	SolidityParserRULE_catchClause                  = 52
	SolidityParserRULE_whileStatement               = 53
	SolidityParserRULE_simpleStatement              = 54
	SolidityParserRULE_uncheckedStatement           = 55
	SolidityParserRULE_forStatement                 = 56
	SolidityParserRULE_inlineAssemblyStatement      = 57
	SolidityParserRULE_inlineAssemblyStatementFlag  = 58
	SolidityParserRULE_doWhileStatement             = 59
	SolidityParserRULE_continueStatement            = 60
	SolidityParserRULE_breakStatement               = 61
	SolidityParserRULE_returnStatement              = 62
	SolidityParserRULE_throwStatement               = 63
	SolidityParserRULE_emitStatement                = 64
	SolidityParserRULE_revertStatement              = 65
	SolidityParserRULE_variableDeclarationStatement = 66
	SolidityParserRULE_variableDeclarationList      = 67
	SolidityParserRULE_identifierList               = 68
	SolidityParserRULE_elementaryTypeName           = 69
	SolidityParserRULE_expression                   = 70
	SolidityParserRULE_primaryExpression            = 71
	SolidityParserRULE_expressionList               = 72
	SolidityParserRULE_nameValueList                = 73
	SolidityParserRULE_nameValue                    = 74
	SolidityParserRULE_functionCallArguments        = 75
	SolidityParserRULE_functionCall                 = 76
	SolidityParserRULE_assemblyBlock                = 77
	SolidityParserRULE_assemblyItem                 = 78
	SolidityParserRULE_assemblyExpression           = 79
	SolidityParserRULE_assemblyMember               = 80
	SolidityParserRULE_assemblyCall                 = 81
	SolidityParserRULE_assemblyLocalDefinition      = 82
	SolidityParserRULE_assemblyAssignment           = 83
	SolidityParserRULE_assemblyIdentifierOrList     = 84
	SolidityParserRULE_assemblyIdentifierList       = 85
	SolidityParserRULE_assemblyStackAssignment      = 86
	SolidityParserRULE_labelDefinition              = 87
	SolidityParserRULE_assemblySwitch               = 88
	SolidityParserRULE_assemblyCase                 = 89
	SolidityParserRULE_assemblyFunctionDefinition   = 90
	SolidityParserRULE_assemblyFunctionReturns      = 91
	SolidityParserRULE_assemblyFor                  = 92
	SolidityParserRULE_assemblyIf                   = 93
	SolidityParserRULE_assemblyLiteral              = 94
	SolidityParserRULE_tupleExpression              = 95
	SolidityParserRULE_numberLiteral                = 96
	SolidityParserRULE_identifier                   = 97
	SolidityParserRULE_hexLiteral                   = 98
	SolidityParserRULE_overrideSpecifier            = 99
	SolidityParserRULE_stringLiteral                = 100
)

// ISourceUnitContext is an interface to support dynamic dispatch.
type ISourceUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllPragmaDirective() []IPragmaDirectiveContext
	PragmaDirective(i int) IPragmaDirectiveContext
	AllImportDirective() []IImportDirectiveContext
	ImportDirective(i int) IImportDirectiveContext
	AllContractDefinition() []IContractDefinitionContext
	ContractDefinition(i int) IContractDefinitionContext
	AllEnumDefinition() []IEnumDefinitionContext
	EnumDefinition(i int) IEnumDefinitionContext
	AllStructDefinition() []IStructDefinitionContext
	StructDefinition(i int) IStructDefinitionContext
	AllFunctionDefinition() []IFunctionDefinitionContext
	FunctionDefinition(i int) IFunctionDefinitionContext
	AllFileLevelConstant() []IFileLevelConstantContext
	FileLevelConstant(i int) IFileLevelConstantContext
	AllCustomErrorDefinition() []ICustomErrorDefinitionContext
	CustomErrorDefinition(i int) ICustomErrorDefinitionContext
	AllTypeDefinition() []ITypeDefinitionContext
	TypeDefinition(i int) ITypeDefinitionContext
	AllUsingForDeclaration() []IUsingForDeclarationContext
	UsingForDeclaration(i int) IUsingForDeclarationContext

	// IsSourceUnitContext differentiates from other interfaces.
	IsSourceUnitContext()
}

type SourceUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceUnitContext() *SourceUnitContext {
	var p = new(SourceUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_sourceUnit
	return p
}

func (*SourceUnitContext) IsSourceUnitContext() {}

func NewSourceUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceUnitContext {
	var p = new(SourceUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_sourceUnit

	return p
}

func (s *SourceUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(SolidityParserEOF, 0)
}

func (s *SourceUnitContext) AllPragmaDirective() []IPragmaDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPragmaDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IPragmaDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPragmaDirectiveContext); ok {
			tst[i] = t.(IPragmaDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) PragmaDirective(i int) IPragmaDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPragmaDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPragmaDirectiveContext)
}

func (s *SourceUnitContext) AllImportDirective() []IImportDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IImportDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportDirectiveContext); ok {
			tst[i] = t.(IImportDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) ImportDirective(i int) IImportDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDirectiveContext)
}

func (s *SourceUnitContext) AllContractDefinition() []IContractDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IContractDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IContractDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IContractDefinitionContext); ok {
			tst[i] = t.(IContractDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) ContractDefinition(i int) IContractDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContractDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContractDefinitionContext)
}

func (s *SourceUnitContext) AllEnumDefinition() []IEnumDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IEnumDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumDefinitionContext); ok {
			tst[i] = t.(IEnumDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) EnumDefinition(i int) IEnumDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDefinitionContext)
}

func (s *SourceUnitContext) AllStructDefinition() []IStructDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStructDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IStructDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStructDefinitionContext); ok {
			tst[i] = t.(IStructDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) StructDefinition(i int) IStructDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDefinitionContext)
}

func (s *SourceUnitContext) AllFunctionDefinition() []IFunctionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IFunctionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionDefinitionContext); ok {
			tst[i] = t.(IFunctionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) FunctionDefinition(i int) IFunctionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDefinitionContext)
}

func (s *SourceUnitContext) AllFileLevelConstant() []IFileLevelConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileLevelConstantContext); ok {
			len++
		}
	}

	tst := make([]IFileLevelConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileLevelConstantContext); ok {
			tst[i] = t.(IFileLevelConstantContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) FileLevelConstant(i int) IFileLevelConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileLevelConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileLevelConstantContext)
}

func (s *SourceUnitContext) AllCustomErrorDefinition() []ICustomErrorDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICustomErrorDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ICustomErrorDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICustomErrorDefinitionContext); ok {
			tst[i] = t.(ICustomErrorDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) CustomErrorDefinition(i int) ICustomErrorDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomErrorDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomErrorDefinitionContext)
}

func (s *SourceUnitContext) AllTypeDefinition() []ITypeDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ITypeDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDefinitionContext); ok {
			tst[i] = t.(ITypeDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) TypeDefinition(i int) ITypeDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionContext)
}

func (s *SourceUnitContext) AllUsingForDeclaration() []IUsingForDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUsingForDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IUsingForDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUsingForDeclarationContext); ok {
			tst[i] = t.(IUsingForDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) UsingForDeclaration(i int) IUsingForDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingForDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingForDeclarationContext)
}

func (s *SourceUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterSourceUnit(s)
	}
}

func (s *SourceUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitSourceUnit(s)
	}
}

func (p *SolidityParser) SourceUnit() (localctx ISourceUnitContext) {
	this := p
	_ = this

	localctx = NewSourceUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SolidityParserRULE_sourceUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(214)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-2305234807432531967) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-1004021107709181949) != 0) {
		p.SetState(212)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(202)
				p.PragmaDirective()
			}

		case 2:
			{
				p.SetState(203)
				p.ImportDirective()
			}

		case 3:
			{
				p.SetState(204)
				p.ContractDefinition()
			}

		case 4:
			{
				p.SetState(205)
				p.EnumDefinition()
			}

		case 5:
			{
				p.SetState(206)
				p.StructDefinition()
			}

		case 6:
			{
				p.SetState(207)
				p.FunctionDefinition()
			}

		case 7:
			{
				p.SetState(208)
				p.FileLevelConstant()
			}

		case 8:
			{
				p.SetState(209)
				p.CustomErrorDefinition()
			}

		case 9:
			{
				p.SetState(210)
				p.TypeDefinition()
			}

		case 10:
			{
				p.SetState(211)
				p.UsingForDeclaration()
			}

		}

		p.SetState(216)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(217)
		p.Match(SolidityParserEOF)
	}

	return localctx
}

// IPragmaDirectiveContext is an interface to support dynamic dispatch.
type IPragmaDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PragmaName() IPragmaNameContext
	PragmaValue() IPragmaValueContext

	// IsPragmaDirectiveContext differentiates from other interfaces.
	IsPragmaDirectiveContext()
}

type PragmaDirectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragmaDirectiveContext() *PragmaDirectiveContext {
	var p = new(PragmaDirectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_pragmaDirective
	return p
}

func (*PragmaDirectiveContext) IsPragmaDirectiveContext() {}

func NewPragmaDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PragmaDirectiveContext {
	var p = new(PragmaDirectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_pragmaDirective

	return p
}

func (s *PragmaDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *PragmaDirectiveContext) PragmaName() IPragmaNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPragmaNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPragmaNameContext)
}

func (s *PragmaDirectiveContext) PragmaValue() IPragmaValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPragmaValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPragmaValueContext)
}

func (s *PragmaDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PragmaDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PragmaDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterPragmaDirective(s)
	}
}

func (s *PragmaDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitPragmaDirective(s)
	}
}

func (p *SolidityParser) PragmaDirective() (localctx IPragmaDirectiveContext) {
	this := p
	_ = this

	localctx = NewPragmaDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SolidityParserRULE_pragmaDirective)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(219)
		p.Match(SolidityParserT__0)
	}
	{
		p.SetState(220)
		p.PragmaName()
	}
	{
		p.SetState(221)
		p.PragmaValue()
	}
	{
		p.SetState(222)
		p.Match(SolidityParserT__1)
	}

	return localctx
}

// IPragmaNameContext is an interface to support dynamic dispatch.
type IPragmaNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsPragmaNameContext differentiates from other interfaces.
	IsPragmaNameContext()
}

type PragmaNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragmaNameContext() *PragmaNameContext {
	var p = new(PragmaNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_pragmaName
	return p
}

func (*PragmaNameContext) IsPragmaNameContext() {}

func NewPragmaNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PragmaNameContext {
	var p = new(PragmaNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_pragmaName

	return p
}

func (s *PragmaNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PragmaNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PragmaNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PragmaNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PragmaNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterPragmaName(s)
	}
}

func (s *PragmaNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitPragmaName(s)
	}
}

func (p *SolidityParser) PragmaName() (localctx IPragmaNameContext) {
	this := p
	_ = this

	localctx = NewPragmaNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SolidityParserRULE_pragmaName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(224)
		p.Identifier()
	}

	return localctx
}

// IPragmaValueContext is an interface to support dynamic dispatch.
type IPragmaValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Version() IVersionContext
	Expression() IExpressionContext

	// IsPragmaValueContext differentiates from other interfaces.
	IsPragmaValueContext()
}

type PragmaValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragmaValueContext() *PragmaValueContext {
	var p = new(PragmaValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_pragmaValue
	return p
}

func (*PragmaValueContext) IsPragmaValueContext() {}

func NewPragmaValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PragmaValueContext {
	var p = new(PragmaValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_pragmaValue

	return p
}

func (s *PragmaValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PragmaValueContext) Version() IVersionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionContext)
}

func (s *PragmaValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PragmaValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PragmaValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PragmaValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterPragmaValue(s)
	}
}

func (s *PragmaValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitPragmaValue(s)
	}
}

func (p *SolidityParser) PragmaValue() (localctx IPragmaValueContext) {
	this := p
	_ = this

	localctx = NewPragmaValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SolidityParserRULE_pragmaValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(229)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(226)
			p.Match(SolidityParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(227)
			p.Version()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(228)
			p.expression(0)
		}

	}

	return localctx
}

// IVersionContext is an interface to support dynamic dispatch.
type IVersionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVersionConstraint() []IVersionConstraintContext
	VersionConstraint(i int) IVersionConstraintContext

	// IsVersionContext differentiates from other interfaces.
	IsVersionContext()
}

type VersionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionContext() *VersionContext {
	var p = new(VersionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_version
	return p
}

func (*VersionContext) IsVersionContext() {}

func NewVersionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionContext {
	var p = new(VersionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_version

	return p
}

func (s *VersionContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionContext) AllVersionConstraint() []IVersionConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVersionConstraintContext); ok {
			len++
		}
	}

	tst := make([]IVersionConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVersionConstraintContext); ok {
			tst[i] = t.(IVersionConstraintContext)
			i++
		}
	}

	return tst
}

func (s *VersionContext) VersionConstraint(i int) IVersionConstraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionConstraintContext)
}

func (s *VersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVersion(s)
	}
}

func (s *VersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVersion(s)
	}
}

func (p *SolidityParser) Version() (localctx IVersionContext) {
	this := p
	_ = this

	localctx = NewVersionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SolidityParserRULE_version)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(231)
		p.VersionConstraint()
	}
	p.SetState(238)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4080) != 0) || _la == SolidityParserDecimalNumber || _la == SolidityParserVersionLiteral {
		p.SetState(233)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SolidityParserT__3 {
			{
				p.SetState(232)
				p.Match(SolidityParserT__3)
			}

		}
		{
			p.SetState(235)
			p.VersionConstraint()
		}

		p.SetState(240)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IVersionOperatorContext is an interface to support dynamic dispatch.
type IVersionOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsVersionOperatorContext differentiates from other interfaces.
	IsVersionOperatorContext()
}

type VersionOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionOperatorContext() *VersionOperatorContext {
	var p = new(VersionOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_versionOperator
	return p
}

func (*VersionOperatorContext) IsVersionOperatorContext() {}

func NewVersionOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionOperatorContext {
	var p = new(VersionOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_versionOperator

	return p
}

func (s *VersionOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *VersionOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVersionOperator(s)
	}
}

func (s *VersionOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVersionOperator(s)
	}
}

func (p *SolidityParser) VersionOperator() (localctx IVersionOperatorContext) {
	this := p
	_ = this

	localctx = NewVersionOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SolidityParserRULE_versionOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(241)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4064) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IVersionConstraintContext is an interface to support dynamic dispatch.
type IVersionConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VersionLiteral() antlr.TerminalNode
	VersionOperator() IVersionOperatorContext
	DecimalNumber() antlr.TerminalNode

	// IsVersionConstraintContext differentiates from other interfaces.
	IsVersionConstraintContext()
}

type VersionConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionConstraintContext() *VersionConstraintContext {
	var p = new(VersionConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_versionConstraint
	return p
}

func (*VersionConstraintContext) IsVersionConstraintContext() {}

func NewVersionConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionConstraintContext {
	var p = new(VersionConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_versionConstraint

	return p
}

func (s *VersionConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionConstraintContext) VersionLiteral() antlr.TerminalNode {
	return s.GetToken(SolidityParserVersionLiteral, 0)
}

func (s *VersionConstraintContext) VersionOperator() IVersionOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionOperatorContext)
}

func (s *VersionConstraintContext) DecimalNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserDecimalNumber, 0)
}

func (s *VersionConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVersionConstraint(s)
	}
}

func (s *VersionConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVersionConstraint(s)
	}
}

func (p *SolidityParser) VersionConstraint() (localctx IVersionConstraintContext) {
	this := p
	_ = this

	localctx = NewVersionConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SolidityParserRULE_versionConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(251)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(244)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4064) != 0 {
			{
				p.SetState(243)
				p.VersionOperator()
			}

		}
		{
			p.SetState(246)
			p.Match(SolidityParserVersionLiteral)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(248)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4064) != 0 {
			{
				p.SetState(247)
				p.VersionOperator()
			}

		}
		{
			p.SetState(250)
			p.Match(SolidityParserDecimalNumber)
		}

	}

	return localctx
}

// IImportDeclarationContext is an interface to support dynamic dispatch.
type IImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsImportDeclarationContext differentiates from other interfaces.
	IsImportDeclarationContext()
}

type ImportDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeclarationContext() *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_importDeclaration
	return p
}

func (*ImportDeclarationContext) IsImportDeclarationContext() {}

func NewImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_importDeclaration

	return p
}

func (s *ImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclarationContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ImportDeclarationContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterImportDeclaration(s)
	}
}

func (s *ImportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitImportDeclaration(s)
	}
}

func (p *SolidityParser) ImportDeclaration() (localctx IImportDeclarationContext) {
	this := p
	_ = this

	localctx = NewImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SolidityParserRULE_importDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(253)
		p.Identifier()
	}
	p.SetState(256)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__11 {
		{
			p.SetState(254)
			p.Match(SolidityParserT__11)
		}
		{
			p.SetState(255)
			p.Identifier()
		}

	}

	return localctx
}

// IImportDirectiveContext is an interface to support dynamic dispatch.
type IImportDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ImportPath() IImportPathContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllImportDeclaration() []IImportDeclarationContext
	ImportDeclaration(i int) IImportDeclarationContext

	// IsImportDirectiveContext differentiates from other interfaces.
	IsImportDirectiveContext()
}

type ImportDirectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDirectiveContext() *ImportDirectiveContext {
	var p = new(ImportDirectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_importDirective
	return p
}

func (*ImportDirectiveContext) IsImportDirectiveContext() {}

func NewImportDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDirectiveContext {
	var p = new(ImportDirectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_importDirective

	return p
}

func (s *ImportDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDirectiveContext) ImportPath() IImportPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportPathContext)
}

func (s *ImportDirectiveContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ImportDirectiveContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportDirectiveContext) AllImportDeclaration() []IImportDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IImportDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportDeclarationContext); ok {
			tst[i] = t.(IImportDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ImportDirectiveContext) ImportDeclaration(i int) IImportDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclarationContext)
}

func (s *ImportDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterImportDirective(s)
	}
}

func (s *ImportDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitImportDirective(s)
	}
}

func (p *SolidityParser) ImportDirective() (localctx IImportDirectiveContext) {
	this := p
	_ = this

	localctx = NewImportDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SolidityParserRULE_importDirective)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(294)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(258)
			p.Match(SolidityParserT__12)
		}
		{
			p.SetState(259)
			p.ImportPath()
		}
		p.SetState(262)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SolidityParserT__11 {
			{
				p.SetState(260)
				p.Match(SolidityParserT__11)
			}
			{
				p.SetState(261)
				p.Identifier()
			}

		}
		{
			p.SetState(264)
			p.Match(SolidityParserT__1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(266)
			p.Match(SolidityParserT__12)
		}
		p.SetState(269)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SolidityParserT__2:
			{
				p.SetState(267)
				p.Match(SolidityParserT__2)
			}

		case SolidityParserT__13, SolidityParserT__24, SolidityParserT__43, SolidityParserT__49, SolidityParserT__61, SolidityParserT__94, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier:
			{
				p.SetState(268)
				p.Identifier()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(273)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SolidityParserT__11 {
			{
				p.SetState(271)
				p.Match(SolidityParserT__11)
			}
			{
				p.SetState(272)
				p.Identifier()
			}

		}
		{
			p.SetState(275)
			p.Match(SolidityParserT__13)
		}
		{
			p.SetState(276)
			p.ImportPath()
		}
		{
			p.SetState(277)
			p.Match(SolidityParserT__1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(279)
			p.Match(SolidityParserT__12)
		}
		{
			p.SetState(280)
			p.Match(SolidityParserT__14)
		}
		{
			p.SetState(281)
			p.ImportDeclaration()
		}
		p.SetState(286)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserT__15 {
			{
				p.SetState(282)
				p.Match(SolidityParserT__15)
			}
			{
				p.SetState(283)
				p.ImportDeclaration()
			}

			p.SetState(288)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(289)
			p.Match(SolidityParserT__16)
		}
		{
			p.SetState(290)
			p.Match(SolidityParserT__13)
		}
		{
			p.SetState(291)
			p.ImportPath()
		}
		{
			p.SetState(292)
			p.Match(SolidityParserT__1)
		}

	}

	return localctx
}

// IImportPathContext is an interface to support dynamic dispatch.
type IImportPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteralFragment() antlr.TerminalNode

	// IsImportPathContext differentiates from other interfaces.
	IsImportPathContext()
}

type ImportPathContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportPathContext() *ImportPathContext {
	var p = new(ImportPathContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_importPath
	return p
}

func (*ImportPathContext) IsImportPathContext() {}

func NewImportPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportPathContext {
	var p = new(ImportPathContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_importPath

	return p
}

func (s *ImportPathContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportPathContext) StringLiteralFragment() antlr.TerminalNode {
	return s.GetToken(SolidityParserStringLiteralFragment, 0)
}

func (s *ImportPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterImportPath(s)
	}
}

func (s *ImportPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitImportPath(s)
	}
}

func (p *SolidityParser) ImportPath() (localctx IImportPathContext) {
	this := p
	_ = this

	localctx = NewImportPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SolidityParserRULE_importPath)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(296)
		p.Match(SolidityParserStringLiteralFragment)
	}

	return localctx
}

// IContractDefinitionContext is an interface to support dynamic dispatch.
type IContractDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllInheritanceSpecifier() []IInheritanceSpecifierContext
	InheritanceSpecifier(i int) IInheritanceSpecifierContext
	AllContractPart() []IContractPartContext
	ContractPart(i int) IContractPartContext

	// IsContractDefinitionContext differentiates from other interfaces.
	IsContractDefinitionContext()
}

type ContractDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContractDefinitionContext() *ContractDefinitionContext {
	var p = new(ContractDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_contractDefinition
	return p
}

func (*ContractDefinitionContext) IsContractDefinitionContext() {}

func NewContractDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContractDefinitionContext {
	var p = new(ContractDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_contractDefinition

	return p
}

func (s *ContractDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ContractDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ContractDefinitionContext) AllInheritanceSpecifier() []IInheritanceSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInheritanceSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IInheritanceSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInheritanceSpecifierContext); ok {
			tst[i] = t.(IInheritanceSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *ContractDefinitionContext) InheritanceSpecifier(i int) IInheritanceSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritanceSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritanceSpecifierContext)
}

func (s *ContractDefinitionContext) AllContractPart() []IContractPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IContractPartContext); ok {
			len++
		}
	}

	tst := make([]IContractPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IContractPartContext); ok {
			tst[i] = t.(IContractPartContext)
			i++
		}
	}

	return tst
}

func (s *ContractDefinitionContext) ContractPart(i int) IContractPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContractPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContractPartContext)
}

func (s *ContractDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContractDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContractDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterContractDefinition(s)
	}
}

func (s *ContractDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitContractDefinition(s)
	}
}

func (p *SolidityParser) ContractDefinition() (localctx IContractDefinitionContext) {
	this := p
	_ = this

	localctx = NewContractDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SolidityParserRULE_contractDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(299)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__17 {
		{
			p.SetState(298)
			p.Match(SolidityParserT__17)
		}

	}
	{
		p.SetState(301)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3670016) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(302)
		p.Identifier()
	}
	p.SetState(312)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__21 {
		{
			p.SetState(303)
			p.Match(SolidityParserT__21)
		}
		{
			p.SetState(304)
			p.InheritanceSpecifier()
		}
		p.SetState(309)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserT__15 {
			{
				p.SetState(305)
				p.Match(SolidityParserT__15)
			}
			{
				p.SetState(306)
				p.InheritanceSpecifier()
			}

			p.SetState(311)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(314)
		p.Match(SolidityParserT__14)
	}
	p.SetState(318)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-14)) & ^0x3f) == 0 && ((int64(1)<<(_la-14))&8725798596909057) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&16244801661) != 0) {
		{
			p.SetState(315)
			p.ContractPart()
		}

		p.SetState(320)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(321)
		p.Match(SolidityParserT__16)
	}

	return localctx
}

// IInheritanceSpecifierContext is an interface to support dynamic dispatch.
type IInheritanceSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserDefinedTypeName() IUserDefinedTypeNameContext
	ExpressionList() IExpressionListContext

	// IsInheritanceSpecifierContext differentiates from other interfaces.
	IsInheritanceSpecifierContext()
}

type InheritanceSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritanceSpecifierContext() *InheritanceSpecifierContext {
	var p = new(InheritanceSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_inheritanceSpecifier
	return p
}

func (*InheritanceSpecifierContext) IsInheritanceSpecifierContext() {}

func NewInheritanceSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritanceSpecifierContext {
	var p = new(InheritanceSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_inheritanceSpecifier

	return p
}

func (s *InheritanceSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritanceSpecifierContext) UserDefinedTypeName() IUserDefinedTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedTypeNameContext)
}

func (s *InheritanceSpecifierContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *InheritanceSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritanceSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InheritanceSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterInheritanceSpecifier(s)
	}
}

func (s *InheritanceSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitInheritanceSpecifier(s)
	}
}

func (p *SolidityParser) InheritanceSpecifier() (localctx IInheritanceSpecifierContext) {
	this := p
	_ = this

	localctx = NewInheritanceSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SolidityParserRULE_inheritanceSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(323)
		p.UserDefinedTypeName()
	}
	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__22 {
		{
			p.SetState(324)
			p.Match(SolidityParserT__22)
		}
		p.SetState(326)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-6)) & ^0x3f) == 0 && ((int64(1)<<(_la-6))&-72038554396917503) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&524744174868627459) != 0) {
			{
				p.SetState(325)
				p.ExpressionList()
			}

		}
		{
			p.SetState(328)
			p.Match(SolidityParserT__23)
		}

	}

	return localctx
}

// IContractPartContext is an interface to support dynamic dispatch.
type IContractPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StateVariableDeclaration() IStateVariableDeclarationContext
	UsingForDeclaration() IUsingForDeclarationContext
	StructDefinition() IStructDefinitionContext
	ModifierDefinition() IModifierDefinitionContext
	FunctionDefinition() IFunctionDefinitionContext
	EventDefinition() IEventDefinitionContext
	EnumDefinition() IEnumDefinitionContext
	CustomErrorDefinition() ICustomErrorDefinitionContext
	TypeDefinition() ITypeDefinitionContext

	// IsContractPartContext differentiates from other interfaces.
	IsContractPartContext()
}

type ContractPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContractPartContext() *ContractPartContext {
	var p = new(ContractPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_contractPart
	return p
}

func (*ContractPartContext) IsContractPartContext() {}

func NewContractPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContractPartContext {
	var p = new(ContractPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_contractPart

	return p
}

func (s *ContractPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ContractPartContext) StateVariableDeclaration() IStateVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStateVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStateVariableDeclarationContext)
}

func (s *ContractPartContext) UsingForDeclaration() IUsingForDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingForDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingForDeclarationContext)
}

func (s *ContractPartContext) StructDefinition() IStructDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDefinitionContext)
}

func (s *ContractPartContext) ModifierDefinition() IModifierDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierDefinitionContext)
}

func (s *ContractPartContext) FunctionDefinition() IFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDefinitionContext)
}

func (s *ContractPartContext) EventDefinition() IEventDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventDefinitionContext)
}

func (s *ContractPartContext) EnumDefinition() IEnumDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDefinitionContext)
}

func (s *ContractPartContext) CustomErrorDefinition() ICustomErrorDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomErrorDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomErrorDefinitionContext)
}

func (s *ContractPartContext) TypeDefinition() ITypeDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionContext)
}

func (s *ContractPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContractPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContractPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterContractPart(s)
	}
}

func (s *ContractPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitContractPart(s)
	}
}

func (p *SolidityParser) ContractPart() (localctx IContractPartContext) {
	this := p
	_ = this

	localctx = NewContractPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SolidityParserRULE_contractPart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(340)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(331)
			p.StateVariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(332)
			p.UsingForDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(333)
			p.StructDefinition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(334)
			p.ModifierDefinition()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(335)
			p.FunctionDefinition()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(336)
			p.EventDefinition()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(337)
			p.EnumDefinition()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(338)
			p.CustomErrorDefinition()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(339)
			p.TypeDefinition()
		}

	}

	return localctx
}

// IStateVariableDeclarationContext is an interface to support dynamic dispatch.
type IStateVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	Identifier() IIdentifierContext
	AllPublicKeyword() []antlr.TerminalNode
	PublicKeyword(i int) antlr.TerminalNode
	AllInternalKeyword() []antlr.TerminalNode
	InternalKeyword(i int) antlr.TerminalNode
	AllPrivateKeyword() []antlr.TerminalNode
	PrivateKeyword(i int) antlr.TerminalNode
	AllConstantKeyword() []antlr.TerminalNode
	ConstantKeyword(i int) antlr.TerminalNode
	AllImmutableKeyword() []antlr.TerminalNode
	ImmutableKeyword(i int) antlr.TerminalNode
	AllOverrideSpecifier() []IOverrideSpecifierContext
	OverrideSpecifier(i int) IOverrideSpecifierContext
	Expression() IExpressionContext

	// IsStateVariableDeclarationContext differentiates from other interfaces.
	IsStateVariableDeclarationContext()
}

type StateVariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStateVariableDeclarationContext() *StateVariableDeclarationContext {
	var p = new(StateVariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_stateVariableDeclaration
	return p
}

func (*StateVariableDeclarationContext) IsStateVariableDeclarationContext() {}

func NewStateVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StateVariableDeclarationContext {
	var p = new(StateVariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_stateVariableDeclaration

	return p
}

func (s *StateVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *StateVariableDeclarationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *StateVariableDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StateVariableDeclarationContext) AllPublicKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPublicKeyword)
}

func (s *StateVariableDeclarationContext) PublicKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPublicKeyword, i)
}

func (s *StateVariableDeclarationContext) AllInternalKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserInternalKeyword)
}

func (s *StateVariableDeclarationContext) InternalKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserInternalKeyword, i)
}

func (s *StateVariableDeclarationContext) AllPrivateKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPrivateKeyword)
}

func (s *StateVariableDeclarationContext) PrivateKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPrivateKeyword, i)
}

func (s *StateVariableDeclarationContext) AllConstantKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserConstantKeyword)
}

func (s *StateVariableDeclarationContext) ConstantKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserConstantKeyword, i)
}

func (s *StateVariableDeclarationContext) AllImmutableKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserImmutableKeyword)
}

func (s *StateVariableDeclarationContext) ImmutableKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserImmutableKeyword, i)
}

func (s *StateVariableDeclarationContext) AllOverrideSpecifier() []IOverrideSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IOverrideSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOverrideSpecifierContext); ok {
			tst[i] = t.(IOverrideSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *StateVariableDeclarationContext) OverrideSpecifier(i int) IOverrideSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverrideSpecifierContext)
}

func (s *StateVariableDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StateVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StateVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StateVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStateVariableDeclaration(s)
	}
}

func (s *StateVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStateVariableDeclaration(s)
	}
}

func (p *SolidityParser) StateVariableDeclaration() (localctx IStateVariableDeclarationContext) {
	this := p
	_ = this

	localctx = NewStateVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SolidityParserRULE_stateVariableDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(342)
		p.typeName(0)
	}
	p.SetState(351)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&13680641) != 0 {
		p.SetState(349)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SolidityParserPublicKeyword:
			{
				p.SetState(343)
				p.Match(SolidityParserPublicKeyword)
			}

		case SolidityParserInternalKeyword:
			{
				p.SetState(344)
				p.Match(SolidityParserInternalKeyword)
			}

		case SolidityParserPrivateKeyword:
			{
				p.SetState(345)
				p.Match(SolidityParserPrivateKeyword)
			}

		case SolidityParserConstantKeyword:
			{
				p.SetState(346)
				p.Match(SolidityParserConstantKeyword)
			}

		case SolidityParserImmutableKeyword:
			{
				p.SetState(347)
				p.Match(SolidityParserImmutableKeyword)
			}

		case SolidityParserT__95:
			{
				p.SetState(348)
				p.OverrideSpecifier()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(354)
		p.Identifier()
	}
	p.SetState(357)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__10 {
		{
			p.SetState(355)
			p.Match(SolidityParserT__10)
		}
		{
			p.SetState(356)
			p.expression(0)
		}

	}
	{
		p.SetState(359)
		p.Match(SolidityParserT__1)
	}

	return localctx
}

// IFileLevelConstantContext is an interface to support dynamic dispatch.
type IFileLevelConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	ConstantKeyword() antlr.TerminalNode
	Identifier() IIdentifierContext
	Expression() IExpressionContext

	// IsFileLevelConstantContext differentiates from other interfaces.
	IsFileLevelConstantContext()
}

type FileLevelConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileLevelConstantContext() *FileLevelConstantContext {
	var p = new(FileLevelConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_fileLevelConstant
	return p
}

func (*FileLevelConstantContext) IsFileLevelConstantContext() {}

func NewFileLevelConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileLevelConstantContext {
	var p = new(FileLevelConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_fileLevelConstant

	return p
}

func (s *FileLevelConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *FileLevelConstantContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *FileLevelConstantContext) ConstantKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserConstantKeyword, 0)
}

func (s *FileLevelConstantContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FileLevelConstantContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FileLevelConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileLevelConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileLevelConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFileLevelConstant(s)
	}
}

func (s *FileLevelConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFileLevelConstant(s)
	}
}

func (p *SolidityParser) FileLevelConstant() (localctx IFileLevelConstantContext) {
	this := p
	_ = this

	localctx = NewFileLevelConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SolidityParserRULE_fileLevelConstant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(361)
		p.typeName(0)
	}
	{
		p.SetState(362)
		p.Match(SolidityParserConstantKeyword)
	}
	{
		p.SetState(363)
		p.Identifier()
	}
	{
		p.SetState(364)
		p.Match(SolidityParserT__10)
	}
	{
		p.SetState(365)
		p.expression(0)
	}
	{
		p.SetState(366)
		p.Match(SolidityParserT__1)
	}

	return localctx
}

// ICustomErrorDefinitionContext is an interface to support dynamic dispatch.
type ICustomErrorDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ParameterList() IParameterListContext

	// IsCustomErrorDefinitionContext differentiates from other interfaces.
	IsCustomErrorDefinitionContext()
}

type CustomErrorDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCustomErrorDefinitionContext() *CustomErrorDefinitionContext {
	var p = new(CustomErrorDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_customErrorDefinition
	return p
}

func (*CustomErrorDefinitionContext) IsCustomErrorDefinitionContext() {}

func NewCustomErrorDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CustomErrorDefinitionContext {
	var p = new(CustomErrorDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_customErrorDefinition

	return p
}

func (s *CustomErrorDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *CustomErrorDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CustomErrorDefinitionContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *CustomErrorDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CustomErrorDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CustomErrorDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterCustomErrorDefinition(s)
	}
}

func (s *CustomErrorDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitCustomErrorDefinition(s)
	}
}

func (p *SolidityParser) CustomErrorDefinition() (localctx ICustomErrorDefinitionContext) {
	this := p
	_ = this

	localctx = NewCustomErrorDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SolidityParserRULE_customErrorDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(368)
		p.Match(SolidityParserT__24)
	}
	{
		p.SetState(369)
		p.Identifier()
	}
	{
		p.SetState(370)
		p.ParameterList()
	}
	{
		p.SetState(371)
		p.Match(SolidityParserT__1)
	}

	return localctx
}

// ITypeDefinitionContext is an interface to support dynamic dispatch.
type ITypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeKeyword() antlr.TerminalNode
	Identifier() IIdentifierContext
	ElementaryTypeName() IElementaryTypeNameContext

	// IsTypeDefinitionContext differentiates from other interfaces.
	IsTypeDefinitionContext()
}

type TypeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefinitionContext() *TypeDefinitionContext {
	var p = new(TypeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_typeDefinition
	return p
}

func (*TypeDefinitionContext) IsTypeDefinitionContext() {}

func NewTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefinitionContext {
	var p = new(TypeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_typeDefinition

	return p
}

func (s *TypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefinitionContext) TypeKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserTypeKeyword, 0)
}

func (s *TypeDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeDefinitionContext) ElementaryTypeName() IElementaryTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementaryTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementaryTypeNameContext)
}

func (s *TypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterTypeDefinition(s)
	}
}

func (s *TypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitTypeDefinition(s)
	}
}

func (p *SolidityParser) TypeDefinition() (localctx ITypeDefinitionContext) {
	this := p
	_ = this

	localctx = NewTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SolidityParserRULE_typeDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(373)
		p.Match(SolidityParserTypeKeyword)
	}
	{
		p.SetState(374)
		p.Identifier()
	}
	{
		p.SetState(375)
		p.Match(SolidityParserT__21)
	}
	{
		p.SetState(376)
		p.ElementaryTypeName()
	}
	{
		p.SetState(377)
		p.Match(SolidityParserT__1)
	}

	return localctx
}

// IUsingForDeclarationContext is an interface to support dynamic dispatch.
type IUsingForDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UsingForObject() IUsingForObjectContext
	TypeName() ITypeNameContext
	GlobalKeyword() antlr.TerminalNode

	// IsUsingForDeclarationContext differentiates from other interfaces.
	IsUsingForDeclarationContext()
}

type UsingForDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingForDeclarationContext() *UsingForDeclarationContext {
	var p = new(UsingForDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_usingForDeclaration
	return p
}

func (*UsingForDeclarationContext) IsUsingForDeclarationContext() {}

func NewUsingForDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingForDeclarationContext {
	var p = new(UsingForDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_usingForDeclaration

	return p
}

func (s *UsingForDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingForDeclarationContext) UsingForObject() IUsingForObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingForObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingForObjectContext)
}

func (s *UsingForDeclarationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *UsingForDeclarationContext) GlobalKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserGlobalKeyword, 0)
}

func (s *UsingForDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingForDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingForDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterUsingForDeclaration(s)
	}
}

func (s *UsingForDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitUsingForDeclaration(s)
	}
}

func (p *SolidityParser) UsingForDeclaration() (localctx IUsingForDeclarationContext) {
	this := p
	_ = this

	localctx = NewUsingForDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SolidityParserRULE_usingForDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		p.Match(SolidityParserT__25)
	}
	{
		p.SetState(380)
		p.UsingForObject()
	}
	{
		p.SetState(381)
		p.Match(SolidityParserT__26)
	}
	p.SetState(384)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__2:
		{
			p.SetState(382)
			p.Match(SolidityParserT__2)
		}

	case SolidityParserT__13, SolidityParserT__24, SolidityParserT__37, SolidityParserT__43, SolidityParserT__45, SolidityParserT__49, SolidityParserT__61, SolidityParserT__62, SolidityParserT__63, SolidityParserT__64, SolidityParserT__65, SolidityParserT__94, SolidityParserInt, SolidityParserUint, SolidityParserByte, SolidityParserFixed, SolidityParserUfixed, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier:
		{
			p.SetState(383)
			p.typeName(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(387)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserGlobalKeyword {
		{
			p.SetState(386)
			p.Match(SolidityParserGlobalKeyword)
		}

	}
	{
		p.SetState(389)
		p.Match(SolidityParserT__1)
	}

	return localctx
}

// IUsingForObjectContext is an interface to support dynamic dispatch.
type IUsingForObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserDefinedTypeName() IUserDefinedTypeNameContext
	AllUsingForObjectDirective() []IUsingForObjectDirectiveContext
	UsingForObjectDirective(i int) IUsingForObjectDirectiveContext

	// IsUsingForObjectContext differentiates from other interfaces.
	IsUsingForObjectContext()
}

type UsingForObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingForObjectContext() *UsingForObjectContext {
	var p = new(UsingForObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_usingForObject
	return p
}

func (*UsingForObjectContext) IsUsingForObjectContext() {}

func NewUsingForObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingForObjectContext {
	var p = new(UsingForObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_usingForObject

	return p
}

func (s *UsingForObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingForObjectContext) UserDefinedTypeName() IUserDefinedTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedTypeNameContext)
}

func (s *UsingForObjectContext) AllUsingForObjectDirective() []IUsingForObjectDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUsingForObjectDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IUsingForObjectDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUsingForObjectDirectiveContext); ok {
			tst[i] = t.(IUsingForObjectDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *UsingForObjectContext) UsingForObjectDirective(i int) IUsingForObjectDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingForObjectDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingForObjectDirectiveContext)
}

func (s *UsingForObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingForObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingForObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterUsingForObject(s)
	}
}

func (s *UsingForObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitUsingForObject(s)
	}
}

func (p *SolidityParser) UsingForObject() (localctx IUsingForObjectContext) {
	this := p
	_ = this

	localctx = NewUsingForObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SolidityParserRULE_usingForObject)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(403)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__13, SolidityParserT__24, SolidityParserT__43, SolidityParserT__49, SolidityParserT__61, SolidityParserT__94, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(391)
			p.UserDefinedTypeName()
		}

	case SolidityParserT__14:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(392)
			p.Match(SolidityParserT__14)
		}
		{
			p.SetState(393)
			p.UsingForObjectDirective()
		}
		p.SetState(398)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserT__15 {
			{
				p.SetState(394)
				p.Match(SolidityParserT__15)
			}
			{
				p.SetState(395)
				p.UsingForObjectDirective()
			}

			p.SetState(400)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(401)
			p.Match(SolidityParserT__16)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUsingForObjectDirectiveContext is an interface to support dynamic dispatch.
type IUsingForObjectDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserDefinedTypeName() IUserDefinedTypeNameContext
	UserDefinableOperators() IUserDefinableOperatorsContext

	// IsUsingForObjectDirectiveContext differentiates from other interfaces.
	IsUsingForObjectDirectiveContext()
}

type UsingForObjectDirectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingForObjectDirectiveContext() *UsingForObjectDirectiveContext {
	var p = new(UsingForObjectDirectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_usingForObjectDirective
	return p
}

func (*UsingForObjectDirectiveContext) IsUsingForObjectDirectiveContext() {}

func NewUsingForObjectDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingForObjectDirectiveContext {
	var p = new(UsingForObjectDirectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_usingForObjectDirective

	return p
}

func (s *UsingForObjectDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingForObjectDirectiveContext) UserDefinedTypeName() IUserDefinedTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedTypeNameContext)
}

func (s *UsingForObjectDirectiveContext) UserDefinableOperators() IUserDefinableOperatorsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinableOperatorsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinableOperatorsContext)
}

func (s *UsingForObjectDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingForObjectDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingForObjectDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterUsingForObjectDirective(s)
	}
}

func (s *UsingForObjectDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitUsingForObjectDirective(s)
	}
}

func (p *SolidityParser) UsingForObjectDirective() (localctx IUsingForObjectDirectiveContext) {
	this := p
	_ = this

	localctx = NewUsingForObjectDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SolidityParserRULE_usingForObjectDirective)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(405)
		p.UserDefinedTypeName()
	}
	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__11 {
		{
			p.SetState(406)
			p.Match(SolidityParserT__11)
		}
		{
			p.SetState(407)
			p.UserDefinableOperators()
		}

	}

	return localctx
}

// IUserDefinableOperatorsContext is an interface to support dynamic dispatch.
type IUserDefinableOperatorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUserDefinableOperatorsContext differentiates from other interfaces.
	IsUserDefinableOperatorsContext()
}

type UserDefinableOperatorsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserDefinableOperatorsContext() *UserDefinableOperatorsContext {
	var p = new(UserDefinableOperatorsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_userDefinableOperators
	return p
}

func (*UserDefinableOperatorsContext) IsUserDefinableOperatorsContext() {}

func NewUserDefinableOperatorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserDefinableOperatorsContext {
	var p = new(UserDefinableOperatorsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_userDefinableOperators

	return p
}

func (s *UserDefinableOperatorsContext) GetParser() antlr.Parser { return s.parser }
func (s *UserDefinableOperatorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserDefinableOperatorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserDefinableOperatorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterUserDefinableOperators(s)
	}
}

func (s *UserDefinableOperatorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitUserDefinableOperators(s)
	}
}

func (p *SolidityParser) UserDefinableOperators() (localctx IUserDefinableOperatorsContext) {
	this := p
	_ = this

	localctx = NewUserDefinableOperatorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SolidityParserRULE_userDefinableOperators)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(410)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&68451043304) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStructDefinitionContext is an interface to support dynamic dispatch.
type IStructDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllVariableDeclaration() []IVariableDeclarationContext
	VariableDeclaration(i int) IVariableDeclarationContext

	// IsStructDefinitionContext differentiates from other interfaces.
	IsStructDefinitionContext()
}

type StructDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructDefinitionContext() *StructDefinitionContext {
	var p = new(StructDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_structDefinition
	return p
}

func (*StructDefinitionContext) IsStructDefinitionContext() {}

func NewStructDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructDefinitionContext {
	var p = new(StructDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_structDefinition

	return p
}

func (s *StructDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *StructDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StructDefinitionContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *StructDefinitionContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *StructDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStructDefinition(s)
	}
}

func (s *StructDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStructDefinition(s)
	}
}

func (p *SolidityParser) StructDefinition() (localctx IStructDefinitionContext) {
	this := p
	_ = this

	localctx = NewStructDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SolidityParserRULE_structDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(412)
		p.Match(SolidityParserT__35)
	}
	{
		p.SetState(413)
		p.Identifier()
	}
	{
		p.SetState(414)
		p.Match(SolidityParserT__14)
	}
	p.SetState(425)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-14)) & ^0x3f) == 0 && ((int64(1)<<(_la-14))&8725798382995457) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100285) != 0) {
		{
			p.SetState(415)
			p.VariableDeclaration()
		}
		{
			p.SetState(416)
			p.Match(SolidityParserT__1)
		}
		p.SetState(422)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ((int64((_la-14)) & ^0x3f) == 0 && ((int64(1)<<(_la-14))&8725798382995457) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100285) != 0) {
			{
				p.SetState(417)
				p.VariableDeclaration()
			}
			{
				p.SetState(418)
				p.Match(SolidityParserT__1)
			}

			p.SetState(424)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(427)
		p.Match(SolidityParserT__16)
	}

	return localctx
}

// IModifierDefinitionContext is an interface to support dynamic dispatch.
type IModifierDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Block() IBlockContext
	ParameterList() IParameterListContext
	AllVirtualKeyword() []antlr.TerminalNode
	VirtualKeyword(i int) antlr.TerminalNode
	AllOverrideSpecifier() []IOverrideSpecifierContext
	OverrideSpecifier(i int) IOverrideSpecifierContext

	// IsModifierDefinitionContext differentiates from other interfaces.
	IsModifierDefinitionContext()
}

type ModifierDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierDefinitionContext() *ModifierDefinitionContext {
	var p = new(ModifierDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_modifierDefinition
	return p
}

func (*ModifierDefinitionContext) IsModifierDefinitionContext() {}

func NewModifierDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierDefinitionContext {
	var p = new(ModifierDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_modifierDefinition

	return p
}

func (s *ModifierDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifierDefinitionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ModifierDefinitionContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ModifierDefinitionContext) AllVirtualKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserVirtualKeyword)
}

func (s *ModifierDefinitionContext) VirtualKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserVirtualKeyword, i)
}

func (s *ModifierDefinitionContext) AllOverrideSpecifier() []IOverrideSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IOverrideSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOverrideSpecifierContext); ok {
			tst[i] = t.(IOverrideSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *ModifierDefinitionContext) OverrideSpecifier(i int) IOverrideSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverrideSpecifierContext)
}

func (s *ModifierDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterModifierDefinition(s)
	}
}

func (s *ModifierDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitModifierDefinition(s)
	}
}

func (p *SolidityParser) ModifierDefinition() (localctx IModifierDefinitionContext) {
	this := p
	_ = this

	localctx = NewModifierDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SolidityParserRULE_modifierDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(429)
		p.Match(SolidityParserT__36)
	}
	{
		p.SetState(430)
		p.Identifier()
	}
	p.SetState(432)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__22 {
		{
			p.SetState(431)
			p.ParameterList()
		}

	}
	p.SetState(438)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserT__95 || _la == SolidityParserVirtualKeyword {
		p.SetState(436)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SolidityParserVirtualKeyword:
			{
				p.SetState(434)
				p.Match(SolidityParserVirtualKeyword)
			}

		case SolidityParserT__95:
			{
				p.SetState(435)
				p.OverrideSpecifier()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(440)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(443)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__1:
		{
			p.SetState(441)
			p.Match(SolidityParserT__1)
		}

	case SolidityParserT__14:
		{
			p.SetState(442)
			p.Block()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IModifierInvocationContext is an interface to support dynamic dispatch.
type IModifierInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ExpressionList() IExpressionListContext

	// IsModifierInvocationContext differentiates from other interfaces.
	IsModifierInvocationContext()
}

type ModifierInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierInvocationContext() *ModifierInvocationContext {
	var p = new(ModifierInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_modifierInvocation
	return p
}

func (*ModifierInvocationContext) IsModifierInvocationContext() {}

func NewModifierInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierInvocationContext {
	var p = new(ModifierInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_modifierInvocation

	return p
}

func (s *ModifierInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierInvocationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifierInvocationContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ModifierInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterModifierInvocation(s)
	}
}

func (s *ModifierInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitModifierInvocation(s)
	}
}

func (p *SolidityParser) ModifierInvocation() (localctx IModifierInvocationContext) {
	this := p
	_ = this

	localctx = NewModifierInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SolidityParserRULE_modifierInvocation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(445)
		p.Identifier()
	}
	p.SetState(451)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__22 {
		{
			p.SetState(446)
			p.Match(SolidityParserT__22)
		}
		p.SetState(448)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-6)) & ^0x3f) == 0 && ((int64(1)<<(_la-6))&-72038554396917503) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&524744174868627459) != 0) {
			{
				p.SetState(447)
				p.ExpressionList()
			}

		}
		{
			p.SetState(450)
			p.Match(SolidityParserT__23)
		}

	}

	return localctx
}

// IFunctionDefinitionContext is an interface to support dynamic dispatch.
type IFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionDescriptor() IFunctionDescriptorContext
	ParameterList() IParameterListContext
	ModifierList() IModifierListContext
	Block() IBlockContext
	ReturnParameters() IReturnParametersContext

	// IsFunctionDefinitionContext differentiates from other interfaces.
	IsFunctionDefinitionContext()
}

type FunctionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDefinitionContext() *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_functionDefinition
	return p
}

func (*FunctionDefinitionContext) IsFunctionDefinitionContext() {}

func NewFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionDefinition

	return p
}

func (s *FunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDefinitionContext) FunctionDescriptor() IFunctionDescriptorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDescriptorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDescriptorContext)
}

func (s *FunctionDefinitionContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FunctionDefinitionContext) ModifierList() IModifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *FunctionDefinitionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionDefinitionContext) ReturnParameters() IReturnParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnParametersContext)
}

func (s *FunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionDefinition(s)
	}
}

func (s *FunctionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionDefinition(s)
	}
}

func (p *SolidityParser) FunctionDefinition() (localctx IFunctionDefinitionContext) {
	this := p
	_ = this

	localctx = NewFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SolidityParserRULE_functionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(453)
		p.FunctionDescriptor()
	}
	{
		p.SetState(454)
		p.ParameterList()
	}
	{
		p.SetState(455)
		p.ModifierList()
	}
	p.SetState(457)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__38 {
		{
			p.SetState(456)
			p.ReturnParameters()
		}

	}
	p.SetState(461)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__1:
		{
			p.SetState(459)
			p.Match(SolidityParserT__1)
		}

	case SolidityParserT__14:
		{
			p.SetState(460)
			p.Block()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunctionDescriptorContext is an interface to support dynamic dispatch.
type IFunctionDescriptorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ConstructorKeyword() antlr.TerminalNode
	FallbackKeyword() antlr.TerminalNode
	ReceiveKeyword() antlr.TerminalNode

	// IsFunctionDescriptorContext differentiates from other interfaces.
	IsFunctionDescriptorContext()
}

type FunctionDescriptorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDescriptorContext() *FunctionDescriptorContext {
	var p = new(FunctionDescriptorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_functionDescriptor
	return p
}

func (*FunctionDescriptorContext) IsFunctionDescriptorContext() {}

func NewFunctionDescriptorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDescriptorContext {
	var p = new(FunctionDescriptorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionDescriptor

	return p
}

func (s *FunctionDescriptorContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDescriptorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionDescriptorContext) ConstructorKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserConstructorKeyword, 0)
}

func (s *FunctionDescriptorContext) FallbackKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserFallbackKeyword, 0)
}

func (s *FunctionDescriptorContext) ReceiveKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserReceiveKeyword, 0)
}

func (s *FunctionDescriptorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDescriptorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDescriptorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionDescriptor(s)
	}
}

func (s *FunctionDescriptorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionDescriptor(s)
	}
}

func (p *SolidityParser) FunctionDescriptor() (localctx IFunctionDescriptorContext) {
	this := p
	_ = this

	localctx = NewFunctionDescriptorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SolidityParserRULE_functionDescriptor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(470)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__37:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(463)
			p.Match(SolidityParserT__37)
		}
		p.SetState(465)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4612829510553845760) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100161) != 0) {
			{
				p.SetState(464)
				p.Identifier()
			}

		}

	case SolidityParserConstructorKeyword:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(467)
			p.Match(SolidityParserConstructorKeyword)
		}

	case SolidityParserFallbackKeyword:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(468)
			p.Match(SolidityParserFallbackKeyword)
		}

	case SolidityParserReceiveKeyword:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(469)
			p.Match(SolidityParserReceiveKeyword)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReturnParametersContext is an interface to support dynamic dispatch.
type IReturnParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParameterList() IParameterListContext

	// IsReturnParametersContext differentiates from other interfaces.
	IsReturnParametersContext()
}

type ReturnParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnParametersContext() *ReturnParametersContext {
	var p = new(ReturnParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_returnParameters
	return p
}

func (*ReturnParametersContext) IsReturnParametersContext() {}

func NewReturnParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnParametersContext {
	var p = new(ReturnParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_returnParameters

	return p
}

func (s *ReturnParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnParametersContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ReturnParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterReturnParameters(s)
	}
}

func (s *ReturnParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitReturnParameters(s)
	}
}

func (p *SolidityParser) ReturnParameters() (localctx IReturnParametersContext) {
	this := p
	_ = this

	localctx = NewReturnParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SolidityParserRULE_returnParameters)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(472)
		p.Match(SolidityParserT__38)
	}
	{
		p.SetState(473)
		p.ParameterList()
	}

	return localctx
}

// IModifierListContext is an interface to support dynamic dispatch.
type IModifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExternalKeyword() []antlr.TerminalNode
	ExternalKeyword(i int) antlr.TerminalNode
	AllPublicKeyword() []antlr.TerminalNode
	PublicKeyword(i int) antlr.TerminalNode
	AllInternalKeyword() []antlr.TerminalNode
	InternalKeyword(i int) antlr.TerminalNode
	AllPrivateKeyword() []antlr.TerminalNode
	PrivateKeyword(i int) antlr.TerminalNode
	AllVirtualKeyword() []antlr.TerminalNode
	VirtualKeyword(i int) antlr.TerminalNode
	AllStateMutability() []IStateMutabilityContext
	StateMutability(i int) IStateMutabilityContext
	AllModifierInvocation() []IModifierInvocationContext
	ModifierInvocation(i int) IModifierInvocationContext
	AllOverrideSpecifier() []IOverrideSpecifierContext
	OverrideSpecifier(i int) IOverrideSpecifierContext

	// IsModifierListContext differentiates from other interfaces.
	IsModifierListContext()
}

type ModifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierListContext() *ModifierListContext {
	var p = new(ModifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_modifierList
	return p
}

func (*ModifierListContext) IsModifierListContext() {}

func NewModifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierListContext {
	var p = new(ModifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_modifierList

	return p
}

func (s *ModifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierListContext) AllExternalKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserExternalKeyword)
}

func (s *ModifierListContext) ExternalKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserExternalKeyword, i)
}

func (s *ModifierListContext) AllPublicKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPublicKeyword)
}

func (s *ModifierListContext) PublicKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPublicKeyword, i)
}

func (s *ModifierListContext) AllInternalKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserInternalKeyword)
}

func (s *ModifierListContext) InternalKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserInternalKeyword, i)
}

func (s *ModifierListContext) AllPrivateKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPrivateKeyword)
}

func (s *ModifierListContext) PrivateKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPrivateKeyword, i)
}

func (s *ModifierListContext) AllVirtualKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserVirtualKeyword)
}

func (s *ModifierListContext) VirtualKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserVirtualKeyword, i)
}

func (s *ModifierListContext) AllStateMutability() []IStateMutabilityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStateMutabilityContext); ok {
			len++
		}
	}

	tst := make([]IStateMutabilityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStateMutabilityContext); ok {
			tst[i] = t.(IStateMutabilityContext)
			i++
		}
	}

	return tst
}

func (s *ModifierListContext) StateMutability(i int) IStateMutabilityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStateMutabilityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStateMutabilityContext)
}

func (s *ModifierListContext) AllModifierInvocation() []IModifierInvocationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierInvocationContext); ok {
			len++
		}
	}

	tst := make([]IModifierInvocationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierInvocationContext); ok {
			tst[i] = t.(IModifierInvocationContext)
			i++
		}
	}

	return tst
}

func (s *ModifierListContext) ModifierInvocation(i int) IModifierInvocationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierInvocationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierInvocationContext)
}

func (s *ModifierListContext) AllOverrideSpecifier() []IOverrideSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IOverrideSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOverrideSpecifierContext); ok {
			tst[i] = t.(IOverrideSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *ModifierListContext) OverrideSpecifier(i int) IOverrideSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverrideSpecifierContext)
}

func (s *ModifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterModifierList(s)
	}
}

func (s *ModifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitModifierList(s)
	}
}

func (p *SolidityParser) ModifierList() (localctx IModifierListContext) {
	this := p
	_ = this

	localctx = NewModifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SolidityParserRULE_modifierList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4612829510553845760) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&14360018947) != 0) {
		p.SetState(483)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(475)
				p.Match(SolidityParserExternalKeyword)
			}

		case 2:
			{
				p.SetState(476)
				p.Match(SolidityParserPublicKeyword)
			}

		case 3:
			{
				p.SetState(477)
				p.Match(SolidityParserInternalKeyword)
			}

		case 4:
			{
				p.SetState(478)
				p.Match(SolidityParserPrivateKeyword)
			}

		case 5:
			{
				p.SetState(479)
				p.Match(SolidityParserVirtualKeyword)
			}

		case 6:
			{
				p.SetState(480)
				p.StateMutability()
			}

		case 7:
			{
				p.SetState(481)
				p.ModifierInvocation()
			}

		case 8:
			{
				p.SetState(482)
				p.OverrideSpecifier()
			}

		}

		p.SetState(487)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEventDefinitionContext is an interface to support dynamic dispatch.
type IEventDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EventParameterList() IEventParameterListContext
	AnonymousKeyword() antlr.TerminalNode

	// IsEventDefinitionContext differentiates from other interfaces.
	IsEventDefinitionContext()
}

type EventDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventDefinitionContext() *EventDefinitionContext {
	var p = new(EventDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_eventDefinition
	return p
}

func (*EventDefinitionContext) IsEventDefinitionContext() {}

func NewEventDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventDefinitionContext {
	var p = new(EventDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_eventDefinition

	return p
}

func (s *EventDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *EventDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EventDefinitionContext) EventParameterList() IEventParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventParameterListContext)
}

func (s *EventDefinitionContext) AnonymousKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserAnonymousKeyword, 0)
}

func (s *EventDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEventDefinition(s)
	}
}

func (s *EventDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEventDefinition(s)
	}
}

func (p *SolidityParser) EventDefinition() (localctx IEventDefinitionContext) {
	this := p
	_ = this

	localctx = NewEventDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SolidityParserRULE_eventDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(488)
		p.Match(SolidityParserT__39)
	}
	{
		p.SetState(489)
		p.Identifier()
	}
	{
		p.SetState(490)
		p.EventParameterList()
	}
	p.SetState(492)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserAnonymousKeyword {
		{
			p.SetState(491)
			p.Match(SolidityParserAnonymousKeyword)
		}

	}
	{
		p.SetState(494)
		p.Match(SolidityParserT__1)
	}

	return localctx
}

// IEnumValueContext is an interface to support dynamic dispatch.
type IEnumValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsEnumValueContext differentiates from other interfaces.
	IsEnumValueContext()
}

type EnumValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueContext() *EnumValueContext {
	var p = new(EnumValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_enumValue
	return p
}

func (*EnumValueContext) IsEnumValueContext() {}

func NewEnumValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueContext {
	var p = new(EnumValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_enumValue

	return p
}

func (s *EnumValueContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEnumValue(s)
	}
}

func (s *EnumValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEnumValue(s)
	}
}

func (p *SolidityParser) EnumValue() (localctx IEnumValueContext) {
	this := p
	_ = this

	localctx = NewEnumValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SolidityParserRULE_enumValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(496)
		p.Identifier()
	}

	return localctx
}

// IEnumDefinitionContext is an interface to support dynamic dispatch.
type IEnumDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllEnumValue() []IEnumValueContext
	EnumValue(i int) IEnumValueContext

	// IsEnumDefinitionContext differentiates from other interfaces.
	IsEnumDefinitionContext()
}

type EnumDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDefinitionContext() *EnumDefinitionContext {
	var p = new(EnumDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_enumDefinition
	return p
}

func (*EnumDefinitionContext) IsEnumDefinitionContext() {}

func NewEnumDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDefinitionContext {
	var p = new(EnumDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_enumDefinition

	return p
}

func (s *EnumDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumDefinitionContext) AllEnumValue() []IEnumValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumValueContext); ok {
			len++
		}
	}

	tst := make([]IEnumValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumValueContext); ok {
			tst[i] = t.(IEnumValueContext)
			i++
		}
	}

	return tst
}

func (s *EnumDefinitionContext) EnumValue(i int) IEnumValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumValueContext)
}

func (s *EnumDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEnumDefinition(s)
	}
}

func (s *EnumDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEnumDefinition(s)
	}
}

func (p *SolidityParser) EnumDefinition() (localctx IEnumDefinitionContext) {
	this := p
	_ = this

	localctx = NewEnumDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SolidityParserRULE_enumDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(498)
		p.Match(SolidityParserT__40)
	}
	{
		p.SetState(499)
		p.Identifier()
	}
	{
		p.SetState(500)
		p.Match(SolidityParserT__14)
	}
	p.SetState(502)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4612829510553845760) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100161) != 0) {
		{
			p.SetState(501)
			p.EnumValue()
		}

	}
	p.SetState(508)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserT__15 {
		{
			p.SetState(504)
			p.Match(SolidityParserT__15)
		}
		{
			p.SetState(505)
			p.EnumValue()
		}

		p.SetState(510)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(511)
		p.Match(SolidityParserT__16)
	}

	return localctx
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParameter() []IParameterContext
	Parameter(i int) IParameterContext

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_parameterList
	return p
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) AllParameter() []IParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterContext); ok {
			len++
		}
	}

	tst := make([]IParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterContext); ok {
			tst[i] = t.(IParameterContext)
			i++
		}
	}

	return tst
}

func (s *ParameterListContext) Parameter(i int) IParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitParameterList(s)
	}
}

func (p *SolidityParser) ParameterList() (localctx IParameterListContext) {
	this := p
	_ = this

	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SolidityParserRULE_parameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(513)
		p.Match(SolidityParserT__22)
	}
	p.SetState(522)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-14)) & ^0x3f) == 0 && ((int64(1)<<(_la-14))&8725798382995457) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100285) != 0) {
		{
			p.SetState(514)
			p.Parameter()
		}
		p.SetState(519)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserT__15 {
			{
				p.SetState(515)
				p.Match(SolidityParserT__15)
			}
			{
				p.SetState(516)
				p.Parameter()
			}

			p.SetState(521)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(524)
		p.Match(SolidityParserT__23)
	}

	return localctx
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	StorageLocation() IStorageLocationContext
	Identifier() IIdentifierContext

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_parameter
	return p
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ParameterContext) StorageLocation() IStorageLocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageLocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageLocationContext)
}

func (s *ParameterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (p *SolidityParser) Parameter() (localctx IParameterContext) {
	this := p
	_ = this

	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SolidityParserRULE_parameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(526)
		p.typeName(0)
	}
	p.SetState(528)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(527)
			p.StorageLocation()
		}

	}
	p.SetState(531)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4612829510553845760) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100161) != 0) {
		{
			p.SetState(530)
			p.Identifier()
		}

	}

	return localctx
}

// IEventParameterListContext is an interface to support dynamic dispatch.
type IEventParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEventParameter() []IEventParameterContext
	EventParameter(i int) IEventParameterContext

	// IsEventParameterListContext differentiates from other interfaces.
	IsEventParameterListContext()
}

type EventParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventParameterListContext() *EventParameterListContext {
	var p = new(EventParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_eventParameterList
	return p
}

func (*EventParameterListContext) IsEventParameterListContext() {}

func NewEventParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventParameterListContext {
	var p = new(EventParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_eventParameterList

	return p
}

func (s *EventParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *EventParameterListContext) AllEventParameter() []IEventParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEventParameterContext); ok {
			len++
		}
	}

	tst := make([]IEventParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEventParameterContext); ok {
			tst[i] = t.(IEventParameterContext)
			i++
		}
	}

	return tst
}

func (s *EventParameterListContext) EventParameter(i int) IEventParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventParameterContext)
}

func (s *EventParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEventParameterList(s)
	}
}

func (s *EventParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEventParameterList(s)
	}
}

func (p *SolidityParser) EventParameterList() (localctx IEventParameterListContext) {
	this := p
	_ = this

	localctx = NewEventParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SolidityParserRULE_eventParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(533)
		p.Match(SolidityParserT__22)
	}
	p.SetState(542)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-14)) & ^0x3f) == 0 && ((int64(1)<<(_la-14))&8725798382995457) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100285) != 0) {
		{
			p.SetState(534)
			p.EventParameter()
		}
		p.SetState(539)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserT__15 {
			{
				p.SetState(535)
				p.Match(SolidityParserT__15)
			}
			{
				p.SetState(536)
				p.EventParameter()
			}

			p.SetState(541)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(544)
		p.Match(SolidityParserT__23)
	}

	return localctx
}

// IEventParameterContext is an interface to support dynamic dispatch.
type IEventParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	IndexedKeyword() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsEventParameterContext differentiates from other interfaces.
	IsEventParameterContext()
}

type EventParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventParameterContext() *EventParameterContext {
	var p = new(EventParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_eventParameter
	return p
}

func (*EventParameterContext) IsEventParameterContext() {}

func NewEventParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventParameterContext {
	var p = new(EventParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_eventParameter

	return p
}

func (s *EventParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *EventParameterContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *EventParameterContext) IndexedKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserIndexedKeyword, 0)
}

func (s *EventParameterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EventParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEventParameter(s)
	}
}

func (s *EventParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEventParameter(s)
	}
}

func (p *SolidityParser) EventParameter() (localctx IEventParameterContext) {
	this := p
	_ = this

	localctx = NewEventParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SolidityParserRULE_eventParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(546)
		p.typeName(0)
	}
	p.SetState(548)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserIndexedKeyword {
		{
			p.SetState(547)
			p.Match(SolidityParserIndexedKeyword)
		}

	}
	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4612829510553845760) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100161) != 0) {
		{
			p.SetState(550)
			p.Identifier()
		}

	}

	return localctx
}

// IFunctionTypeParameterListContext is an interface to support dynamic dispatch.
type IFunctionTypeParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunctionTypeParameter() []IFunctionTypeParameterContext
	FunctionTypeParameter(i int) IFunctionTypeParameterContext

	// IsFunctionTypeParameterListContext differentiates from other interfaces.
	IsFunctionTypeParameterListContext()
}

type FunctionTypeParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeParameterListContext() *FunctionTypeParameterListContext {
	var p = new(FunctionTypeParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_functionTypeParameterList
	return p
}

func (*FunctionTypeParameterListContext) IsFunctionTypeParameterListContext() {}

func NewFunctionTypeParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeParameterListContext {
	var p = new(FunctionTypeParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionTypeParameterList

	return p
}

func (s *FunctionTypeParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeParameterListContext) AllFunctionTypeParameter() []IFunctionTypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionTypeParameterContext); ok {
			len++
		}
	}

	tst := make([]IFunctionTypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionTypeParameterContext); ok {
			tst[i] = t.(IFunctionTypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *FunctionTypeParameterListContext) FunctionTypeParameter(i int) IFunctionTypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeParameterContext)
}

func (s *FunctionTypeParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionTypeParameterList(s)
	}
}

func (s *FunctionTypeParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionTypeParameterList(s)
	}
}

func (p *SolidityParser) FunctionTypeParameterList() (localctx IFunctionTypeParameterListContext) {
	this := p
	_ = this

	localctx = NewFunctionTypeParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SolidityParserRULE_functionTypeParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)
		p.Match(SolidityParserT__22)
	}
	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-14)) & ^0x3f) == 0 && ((int64(1)<<(_la-14))&8725798382995457) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100285) != 0) {
		{
			p.SetState(554)
			p.FunctionTypeParameter()
		}
		p.SetState(559)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserT__15 {
			{
				p.SetState(555)
				p.Match(SolidityParserT__15)
			}
			{
				p.SetState(556)
				p.FunctionTypeParameter()
			}

			p.SetState(561)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(564)
		p.Match(SolidityParserT__23)
	}

	return localctx
}

// IFunctionTypeParameterContext is an interface to support dynamic dispatch.
type IFunctionTypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	StorageLocation() IStorageLocationContext

	// IsFunctionTypeParameterContext differentiates from other interfaces.
	IsFunctionTypeParameterContext()
}

type FunctionTypeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeParameterContext() *FunctionTypeParameterContext {
	var p = new(FunctionTypeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_functionTypeParameter
	return p
}

func (*FunctionTypeParameterContext) IsFunctionTypeParameterContext() {}

func NewFunctionTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeParameterContext {
	var p = new(FunctionTypeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionTypeParameter

	return p
}

func (s *FunctionTypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeParameterContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *FunctionTypeParameterContext) StorageLocation() IStorageLocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageLocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageLocationContext)
}

func (s *FunctionTypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionTypeParameter(s)
	}
}

func (s *FunctionTypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionTypeParameter(s)
	}
}

func (p *SolidityParser) FunctionTypeParameter() (localctx IFunctionTypeParameterContext) {
	this := p
	_ = this

	localctx = NewFunctionTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SolidityParserRULE_functionTypeParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(566)
		p.typeName(0)
	}
	p.SetState(568)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1970324836974592) != 0 {
		{
			p.SetState(567)
			p.StorageLocation()
		}

	}

	return localctx
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	Identifier() IIdentifierContext
	StorageLocation() IStorageLocationContext

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclaration
	return p
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *VariableDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDeclarationContext) StorageLocation() IStorageLocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageLocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageLocationContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (p *SolidityParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	this := p
	_ = this

	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SolidityParserRULE_variableDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(570)
		p.typeName(0)
	}
	p.SetState(572)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(571)
			p.StorageLocation()
		}

	}
	{
		p.SetState(574)
		p.Identifier()
	}

	return localctx
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementaryTypeName() IElementaryTypeNameContext
	UserDefinedTypeName() IUserDefinedTypeNameContext
	Mapping() IMappingContext
	FunctionTypeName() IFunctionTypeNameContext
	PayableKeyword() antlr.TerminalNode
	TypeName() ITypeNameContext
	Expression() IExpressionContext

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_typeName
	return p
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) ElementaryTypeName() IElementaryTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementaryTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementaryTypeNameContext)
}

func (s *TypeNameContext) UserDefinedTypeName() IUserDefinedTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedTypeNameContext)
}

func (s *TypeNameContext) Mapping() IMappingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingContext)
}

func (s *TypeNameContext) FunctionTypeName() IFunctionTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeNameContext)
}

func (s *TypeNameContext) PayableKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserPayableKeyword, 0)
}

func (s *TypeNameContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *TypeNameContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitTypeName(s)
	}
}

func (p *SolidityParser) TypeName() (localctx ITypeNameContext) {
	return p.typeName(0)
}

func (p *SolidityParser) typeName(_p int) (localctx ITypeNameContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITypeNameContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 76
	p.EnterRecursionRule(localctx, 76, SolidityParserRULE_typeName, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(583)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(577)
			p.ElementaryTypeName()
		}

	case 2:
		{
			p.SetState(578)
			p.UserDefinedTypeName()
		}

	case 3:
		{
			p.SetState(579)
			p.Mapping()
		}

	case 4:
		{
			p.SetState(580)
			p.FunctionTypeName()
		}

	case 5:
		{
			p.SetState(581)
			p.Match(SolidityParserT__43)
		}
		{
			p.SetState(582)
			p.Match(SolidityParserPayableKeyword)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(593)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTypeNameContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_typeName)
			p.SetState(585)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
			}
			{
				p.SetState(586)
				p.Match(SolidityParserT__41)
			}
			p.SetState(588)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((int64((_la-6)) & ^0x3f) == 0 && ((int64(1)<<(_la-6))&-72038554396917503) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&524744174868627459) != 0) {
				{
					p.SetState(587)
					p.expression(0)
				}

			}
			{
				p.SetState(590)
				p.Match(SolidityParserT__42)
			}

		}
		p.SetState(595)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext())
	}

	return localctx
}

// IUserDefinedTypeNameContext is an interface to support dynamic dispatch.
type IUserDefinedTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsUserDefinedTypeNameContext differentiates from other interfaces.
	IsUserDefinedTypeNameContext()
}

type UserDefinedTypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserDefinedTypeNameContext() *UserDefinedTypeNameContext {
	var p = new(UserDefinedTypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_userDefinedTypeName
	return p
}

func (*UserDefinedTypeNameContext) IsUserDefinedTypeNameContext() {}

func NewUserDefinedTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserDefinedTypeNameContext {
	var p = new(UserDefinedTypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_userDefinedTypeName

	return p
}

func (s *UserDefinedTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *UserDefinedTypeNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UserDefinedTypeNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UserDefinedTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserDefinedTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserDefinedTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterUserDefinedTypeName(s)
	}
}

func (s *UserDefinedTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitUserDefinedTypeName(s)
	}
}

func (p *SolidityParser) UserDefinedTypeName() (localctx IUserDefinedTypeNameContext) {
	this := p
	_ = this

	localctx = NewUserDefinedTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SolidityParserRULE_userDefinedTypeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(596)
		p.Identifier()
	}
	p.SetState(601)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(597)
				p.Match(SolidityParserT__44)
			}
			{
				p.SetState(598)
				p.Identifier()
			}

		}
		p.SetState(603)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext())
	}

	return localctx
}

// IMappingKeyContext is an interface to support dynamic dispatch.
type IMappingKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementaryTypeName() IElementaryTypeNameContext
	UserDefinedTypeName() IUserDefinedTypeNameContext

	// IsMappingKeyContext differentiates from other interfaces.
	IsMappingKeyContext()
}

type MappingKeyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMappingKeyContext() *MappingKeyContext {
	var p = new(MappingKeyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_mappingKey
	return p
}

func (*MappingKeyContext) IsMappingKeyContext() {}

func NewMappingKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MappingKeyContext {
	var p = new(MappingKeyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_mappingKey

	return p
}

func (s *MappingKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *MappingKeyContext) ElementaryTypeName() IElementaryTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementaryTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementaryTypeNameContext)
}

func (s *MappingKeyContext) UserDefinedTypeName() IUserDefinedTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedTypeNameContext)
}

func (s *MappingKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MappingKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MappingKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterMappingKey(s)
	}
}

func (s *MappingKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitMappingKey(s)
	}
}

func (p *SolidityParser) MappingKey() (localctx IMappingKeyContext) {
	this := p
	_ = this

	localctx = NewMappingKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SolidityParserRULE_mappingKey)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(606)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(604)
			p.ElementaryTypeName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(605)
			p.UserDefinedTypeName()
		}

	}

	return localctx
}

// IMappingContext is an interface to support dynamic dispatch.
type IMappingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MappingKey() IMappingKeyContext
	TypeName() ITypeNameContext
	MappingKeyName() IMappingKeyNameContext
	MappingValueName() IMappingValueNameContext

	// IsMappingContext differentiates from other interfaces.
	IsMappingContext()
}

type MappingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMappingContext() *MappingContext {
	var p = new(MappingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_mapping
	return p
}

func (*MappingContext) IsMappingContext() {}

func NewMappingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MappingContext {
	var p = new(MappingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_mapping

	return p
}

func (s *MappingContext) GetParser() antlr.Parser { return s.parser }

func (s *MappingContext) MappingKey() IMappingKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingKeyContext)
}

func (s *MappingContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *MappingContext) MappingKeyName() IMappingKeyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingKeyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingKeyNameContext)
}

func (s *MappingContext) MappingValueName() IMappingValueNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingValueNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingValueNameContext)
}

func (s *MappingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MappingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MappingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterMapping(s)
	}
}

func (s *MappingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitMapping(s)
	}
}

func (p *SolidityParser) Mapping() (localctx IMappingContext) {
	this := p
	_ = this

	localctx = NewMappingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SolidityParserRULE_mapping)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(608)
		p.Match(SolidityParserT__45)
	}
	{
		p.SetState(609)
		p.Match(SolidityParserT__22)
	}
	{
		p.SetState(610)
		p.MappingKey()
	}
	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4612829510553845760) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100161) != 0) {
		{
			p.SetState(611)
			p.MappingKeyName()
		}

	}
	{
		p.SetState(614)
		p.Match(SolidityParserT__46)
	}
	{
		p.SetState(615)
		p.typeName(0)
	}
	p.SetState(617)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4612829510553845760) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100161) != 0) {
		{
			p.SetState(616)
			p.MappingValueName()
		}

	}
	{
		p.SetState(619)
		p.Match(SolidityParserT__23)
	}

	return localctx
}

// IMappingKeyNameContext is an interface to support dynamic dispatch.
type IMappingKeyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsMappingKeyNameContext differentiates from other interfaces.
	IsMappingKeyNameContext()
}

type MappingKeyNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMappingKeyNameContext() *MappingKeyNameContext {
	var p = new(MappingKeyNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_mappingKeyName
	return p
}

func (*MappingKeyNameContext) IsMappingKeyNameContext() {}

func NewMappingKeyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MappingKeyNameContext {
	var p = new(MappingKeyNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_mappingKeyName

	return p
}

func (s *MappingKeyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *MappingKeyNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MappingKeyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MappingKeyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MappingKeyNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterMappingKeyName(s)
	}
}

func (s *MappingKeyNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitMappingKeyName(s)
	}
}

func (p *SolidityParser) MappingKeyName() (localctx IMappingKeyNameContext) {
	this := p
	_ = this

	localctx = NewMappingKeyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SolidityParserRULE_mappingKeyName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(621)
		p.Identifier()
	}

	return localctx
}

// IMappingValueNameContext is an interface to support dynamic dispatch.
type IMappingValueNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsMappingValueNameContext differentiates from other interfaces.
	IsMappingValueNameContext()
}

type MappingValueNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMappingValueNameContext() *MappingValueNameContext {
	var p = new(MappingValueNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_mappingValueName
	return p
}

func (*MappingValueNameContext) IsMappingValueNameContext() {}

func NewMappingValueNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MappingValueNameContext {
	var p = new(MappingValueNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_mappingValueName

	return p
}

func (s *MappingValueNameContext) GetParser() antlr.Parser { return s.parser }

func (s *MappingValueNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MappingValueNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MappingValueNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MappingValueNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterMappingValueName(s)
	}
}

func (s *MappingValueNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitMappingValueName(s)
	}
}

func (p *SolidityParser) MappingValueName() (localctx IMappingValueNameContext) {
	this := p
	_ = this

	localctx = NewMappingValueNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SolidityParserRULE_mappingValueName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(623)
		p.Identifier()
	}

	return localctx
}

// IFunctionTypeNameContext is an interface to support dynamic dispatch.
type IFunctionTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunctionTypeParameterList() []IFunctionTypeParameterListContext
	FunctionTypeParameterList(i int) IFunctionTypeParameterListContext
	AllInternalKeyword() []antlr.TerminalNode
	InternalKeyword(i int) antlr.TerminalNode
	AllExternalKeyword() []antlr.TerminalNode
	ExternalKeyword(i int) antlr.TerminalNode
	AllStateMutability() []IStateMutabilityContext
	StateMutability(i int) IStateMutabilityContext

	// IsFunctionTypeNameContext differentiates from other interfaces.
	IsFunctionTypeNameContext()
}

type FunctionTypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeNameContext() *FunctionTypeNameContext {
	var p = new(FunctionTypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_functionTypeName
	return p
}

func (*FunctionTypeNameContext) IsFunctionTypeNameContext() {}

func NewFunctionTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeNameContext {
	var p = new(FunctionTypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionTypeName

	return p
}

func (s *FunctionTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeNameContext) AllFunctionTypeParameterList() []IFunctionTypeParameterListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionTypeParameterListContext); ok {
			len++
		}
	}

	tst := make([]IFunctionTypeParameterListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionTypeParameterListContext); ok {
			tst[i] = t.(IFunctionTypeParameterListContext)
			i++
		}
	}

	return tst
}

func (s *FunctionTypeNameContext) FunctionTypeParameterList(i int) IFunctionTypeParameterListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeParameterListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeParameterListContext)
}

func (s *FunctionTypeNameContext) AllInternalKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserInternalKeyword)
}

func (s *FunctionTypeNameContext) InternalKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserInternalKeyword, i)
}

func (s *FunctionTypeNameContext) AllExternalKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserExternalKeyword)
}

func (s *FunctionTypeNameContext) ExternalKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserExternalKeyword, i)
}

func (s *FunctionTypeNameContext) AllStateMutability() []IStateMutabilityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStateMutabilityContext); ok {
			len++
		}
	}

	tst := make([]IStateMutabilityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStateMutabilityContext); ok {
			tst[i] = t.(IStateMutabilityContext)
			i++
		}
	}

	return tst
}

func (s *FunctionTypeNameContext) StateMutability(i int) IStateMutabilityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStateMutabilityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStateMutabilityContext)
}

func (s *FunctionTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionTypeName(s)
	}
}

func (s *FunctionTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionTypeName(s)
	}
}

func (p *SolidityParser) FunctionTypeName() (localctx IFunctionTypeNameContext) {
	this := p
	_ = this

	localctx = NewFunctionTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SolidityParserRULE_functionTypeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(625)
		p.Match(SolidityParserT__37)
	}
	{
		p.SetState(626)
		p.FunctionTypeParameterList()
	}
	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(630)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SolidityParserInternalKeyword:
				{
					p.SetState(627)
					p.Match(SolidityParserInternalKeyword)
				}

			case SolidityParserExternalKeyword:
				{
					p.SetState(628)
					p.Match(SolidityParserExternalKeyword)
				}

			case SolidityParserConstantKeyword, SolidityParserPayableKeyword, SolidityParserPureKeyword, SolidityParserViewKeyword:
				{
					p.SetState(629)
					p.StateMutability()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(634)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())
	}
	p.SetState(637)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(635)
			p.Match(SolidityParserT__38)
		}
		{
			p.SetState(636)
			p.FunctionTypeParameterList()
		}

	}

	return localctx
}

// IStorageLocationContext is an interface to support dynamic dispatch.
type IStorageLocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStorageLocationContext differentiates from other interfaces.
	IsStorageLocationContext()
}

type StorageLocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStorageLocationContext() *StorageLocationContext {
	var p = new(StorageLocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_storageLocation
	return p
}

func (*StorageLocationContext) IsStorageLocationContext() {}

func NewStorageLocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorageLocationContext {
	var p = new(StorageLocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_storageLocation

	return p
}

func (s *StorageLocationContext) GetParser() antlr.Parser { return s.parser }
func (s *StorageLocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageLocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StorageLocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStorageLocation(s)
	}
}

func (s *StorageLocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStorageLocation(s)
	}
}

func (p *SolidityParser) StorageLocation() (localctx IStorageLocationContext) {
	this := p
	_ = this

	localctx = NewStorageLocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SolidityParserRULE_storageLocation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(639)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1970324836974592) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStateMutabilityContext is an interface to support dynamic dispatch.
type IStateMutabilityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PureKeyword() antlr.TerminalNode
	ConstantKeyword() antlr.TerminalNode
	ViewKeyword() antlr.TerminalNode
	PayableKeyword() antlr.TerminalNode

	// IsStateMutabilityContext differentiates from other interfaces.
	IsStateMutabilityContext()
}

type StateMutabilityContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStateMutabilityContext() *StateMutabilityContext {
	var p = new(StateMutabilityContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_stateMutability
	return p
}

func (*StateMutabilityContext) IsStateMutabilityContext() {}

func NewStateMutabilityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StateMutabilityContext {
	var p = new(StateMutabilityContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_stateMutability

	return p
}

func (s *StateMutabilityContext) GetParser() antlr.Parser { return s.parser }

func (s *StateMutabilityContext) PureKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserPureKeyword, 0)
}

func (s *StateMutabilityContext) ConstantKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserConstantKeyword, 0)
}

func (s *StateMutabilityContext) ViewKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserViewKeyword, 0)
}

func (s *StateMutabilityContext) PayableKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserPayableKeyword, 0)
}

func (s *StateMutabilityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StateMutabilityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StateMutabilityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStateMutability(s)
	}
}

func (s *StateMutabilityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStateMutability(s)
	}
}

func (p *SolidityParser) StateMutability() (localctx IStateMutabilityContext) {
	this := p
	_ = this

	localctx = NewStateMutabilityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SolidityParserRULE_stateMutability)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(641)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-110)) & ^0x3f) == 0 && ((int64(1)<<(_la-110))&10369) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *SolidityParser) Block() (localctx IBlockContext) {
	this := p
	_ = this

	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SolidityParserRULE_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(643)
		p.Match(SolidityParserT__14)
	}
	p.SetState(647)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-6)) & ^0x3f) == 0 && ((int64(1)<<(_la-6))&-367988449869055) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&524746648769789955) != 0) {
		{
			p.SetState(644)
			p.Statement()
		}

		p.SetState(649)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(650)
		p.Match(SolidityParserT__16)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IfStatement() IIfStatementContext
	TryStatement() ITryStatementContext
	WhileStatement() IWhileStatementContext
	ForStatement() IForStatementContext
	Block() IBlockContext
	InlineAssemblyStatement() IInlineAssemblyStatementContext
	DoWhileStatement() IDoWhileStatementContext
	ContinueStatement() IContinueStatementContext
	BreakStatement() IBreakStatementContext
	ReturnStatement() IReturnStatementContext
	ThrowStatement() IThrowStatementContext
	EmitStatement() IEmitStatementContext
	SimpleStatement() ISimpleStatementContext
	UncheckedStatement() IUncheckedStatementContext
	RevertStatement() IRevertStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) TryStatement() ITryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *StatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) InlineAssemblyStatement() IInlineAssemblyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineAssemblyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineAssemblyStatementContext)
}

func (s *StatementContext) DoWhileStatement() IDoWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoWhileStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) ThrowStatement() IThrowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementContext) EmitStatement() IEmitStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmitStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmitStatementContext)
}

func (s *StatementContext) SimpleStatement() ISimpleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStatementContext)
}

func (s *StatementContext) UncheckedStatement() IUncheckedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUncheckedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUncheckedStatementContext)
}

func (s *StatementContext) RevertStatement() IRevertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevertStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *SolidityParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SolidityParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(667)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(652)
			p.IfStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(653)
			p.TryStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(654)
			p.WhileStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(655)
			p.ForStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(656)
			p.Block()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(657)
			p.InlineAssemblyStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(658)
			p.DoWhileStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(659)
			p.ContinueStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(660)
			p.BreakStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(661)
			p.ReturnStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(662)
			p.ThrowStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(663)
			p.EmitStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(664)
			p.SimpleStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(665)
			p.UncheckedStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(666)
			p.RevertStatement()
		}

	}

	return localctx
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_expressionStatement
	return p
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (p *SolidityParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	this := p
	_ = this

	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SolidityParserRULE_expressionStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(669)
		p.expression(0)
	}
	{
		p.SetState(670)
		p.Match(SolidityParserT__1)
	}

	return localctx
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_ifStatement
	return p
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (p *SolidityParser) IfStatement() (localctx IIfStatementContext) {
	this := p
	_ = this

	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SolidityParserRULE_ifStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(672)
		p.Match(SolidityParserT__50)
	}
	{
		p.SetState(673)
		p.Match(SolidityParserT__22)
	}
	{
		p.SetState(674)
		p.expression(0)
	}
	{
		p.SetState(675)
		p.Match(SolidityParserT__23)
	}
	{
		p.SetState(676)
		p.Statement()
	}
	p.SetState(679)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(677)
			p.Match(SolidityParserT__51)
		}
		{
			p.SetState(678)
			p.Statement()
		}

	}

	return localctx
}

// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Block() IBlockContext
	ReturnParameters() IReturnParametersContext
	AllCatchClause() []ICatchClauseContext
	CatchClause(i int) ICatchClauseContext

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_tryStatement
	return p
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TryStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryStatementContext) ReturnParameters() IReturnParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnParametersContext)
}

func (s *TryStatementContext) AllCatchClause() []ICatchClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICatchClauseContext); ok {
			len++
		}
	}

	tst := make([]ICatchClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICatchClauseContext); ok {
			tst[i] = t.(ICatchClauseContext)
			i++
		}
	}

	return tst
}

func (s *TryStatementContext) CatchClause(i int) ICatchClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterTryStatement(s)
	}
}

func (s *TryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitTryStatement(s)
	}
}

func (p *SolidityParser) TryStatement() (localctx ITryStatementContext) {
	this := p
	_ = this

	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SolidityParserRULE_tryStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(681)
		p.Match(SolidityParserT__52)
	}
	{
		p.SetState(682)
		p.expression(0)
	}
	p.SetState(684)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__38 {
		{
			p.SetState(683)
			p.ReturnParameters()
		}

	}
	{
		p.SetState(686)
		p.Block()
	}
	p.SetState(688)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SolidityParserT__53 {
		{
			p.SetState(687)
			p.CatchClause()
		}

		p.SetState(690)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	ParameterList() IParameterListContext
	Identifier() IIdentifierContext

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_catchClause
	return p
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchClauseContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *CatchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterCatchClause(s)
	}
}

func (s *CatchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitCatchClause(s)
	}
}

func (p *SolidityParser) CatchClause() (localctx ICatchClauseContext) {
	this := p
	_ = this

	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SolidityParserRULE_catchClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(692)
		p.Match(SolidityParserT__53)
	}
	p.SetState(697)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4612829510562234368) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100161) != 0) {
		p.SetState(694)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4612829510553845760) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100161) != 0) {
			{
				p.SetState(693)
				p.Identifier()
			}

		}
		{
			p.SetState(696)
			p.ParameterList()
		}

	}
	{
		p.SetState(699)
		p.Block()
	}

	return localctx
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Statement() IStatementContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_whileStatement
	return p
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (p *SolidityParser) WhileStatement() (localctx IWhileStatementContext) {
	this := p
	_ = this

	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SolidityParserRULE_whileStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(701)
		p.Match(SolidityParserT__54)
	}
	{
		p.SetState(702)
		p.Match(SolidityParserT__22)
	}
	{
		p.SetState(703)
		p.expression(0)
	}
	{
		p.SetState(704)
		p.Match(SolidityParserT__23)
	}
	{
		p.SetState(705)
		p.Statement()
	}

	return localctx
}

// ISimpleStatementContext is an interface to support dynamic dispatch.
type ISimpleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDeclarationStatement() IVariableDeclarationStatementContext
	ExpressionStatement() IExpressionStatementContext

	// IsSimpleStatementContext differentiates from other interfaces.
	IsSimpleStatementContext()
}

type SimpleStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStatementContext() *SimpleStatementContext {
	var p = new(SimpleStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_simpleStatement
	return p
}

func (*SimpleStatementContext) IsSimpleStatementContext() {}

func NewSimpleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStatementContext {
	var p = new(SimpleStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_simpleStatement

	return p
}

func (s *SimpleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStatementContext) VariableDeclarationStatement() IVariableDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationStatementContext)
}

func (s *SimpleStatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *SimpleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitSimpleStatement(s)
	}
}

func (p *SolidityParser) SimpleStatement() (localctx ISimpleStatementContext) {
	this := p
	_ = this

	localctx = NewSimpleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SolidityParserRULE_simpleStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(709)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(707)
			p.VariableDeclarationStatement()
		}

	case 2:
		{
			p.SetState(708)
			p.ExpressionStatement()
		}

	}

	return localctx
}

// IUncheckedStatementContext is an interface to support dynamic dispatch.
type IUncheckedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext

	// IsUncheckedStatementContext differentiates from other interfaces.
	IsUncheckedStatementContext()
}

type UncheckedStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUncheckedStatementContext() *UncheckedStatementContext {
	var p = new(UncheckedStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_uncheckedStatement
	return p
}

func (*UncheckedStatementContext) IsUncheckedStatementContext() {}

func NewUncheckedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UncheckedStatementContext {
	var p = new(UncheckedStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_uncheckedStatement

	return p
}

func (s *UncheckedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UncheckedStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *UncheckedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UncheckedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UncheckedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterUncheckedStatement(s)
	}
}

func (s *UncheckedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitUncheckedStatement(s)
	}
}

func (p *SolidityParser) UncheckedStatement() (localctx IUncheckedStatementContext) {
	this := p
	_ = this

	localctx = NewUncheckedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SolidityParserRULE_uncheckedStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(711)
		p.Match(SolidityParserT__55)
	}
	{
		p.SetState(712)
		p.Block()
	}

	return localctx
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	SimpleStatement() ISimpleStatementContext
	ExpressionStatement() IExpressionStatementContext
	Expression() IExpressionContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_forStatement
	return p
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) SimpleStatement() ISimpleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStatementContext)
}

func (s *ForStatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *ForStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (p *SolidityParser) ForStatement() (localctx IForStatementContext) {
	this := p
	_ = this

	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SolidityParserRULE_forStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(714)
		p.Match(SolidityParserT__26)
	}
	{
		p.SetState(715)
		p.Match(SolidityParserT__22)
	}
	p.SetState(718)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__5, SolidityParserT__13, SolidityParserT__22, SolidityParserT__24, SolidityParserT__29, SolidityParserT__30, SolidityParserT__37, SolidityParserT__41, SolidityParserT__43, SolidityParserT__45, SolidityParserT__49, SolidityParserT__61, SolidityParserT__62, SolidityParserT__63, SolidityParserT__64, SolidityParserT__65, SolidityParserT__66, SolidityParserT__67, SolidityParserT__68, SolidityParserT__70, SolidityParserT__71, SolidityParserT__94, SolidityParserInt, SolidityParserUint, SolidityParserByte, SolidityParserFixed, SolidityParserUfixed, SolidityParserBooleanLiteral, SolidityParserDecimalNumber, SolidityParserHexNumber, SolidityParserHexLiteralFragment, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserTypeKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier, SolidityParserStringLiteralFragment:
		{
			p.SetState(716)
			p.SimpleStatement()
		}

	case SolidityParserT__1:
		{
			p.SetState(717)
			p.Match(SolidityParserT__1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(722)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__5, SolidityParserT__13, SolidityParserT__22, SolidityParserT__24, SolidityParserT__29, SolidityParserT__30, SolidityParserT__37, SolidityParserT__41, SolidityParserT__43, SolidityParserT__45, SolidityParserT__49, SolidityParserT__61, SolidityParserT__62, SolidityParserT__63, SolidityParserT__64, SolidityParserT__65, SolidityParserT__66, SolidityParserT__67, SolidityParserT__68, SolidityParserT__70, SolidityParserT__71, SolidityParserT__94, SolidityParserInt, SolidityParserUint, SolidityParserByte, SolidityParserFixed, SolidityParserUfixed, SolidityParserBooleanLiteral, SolidityParserDecimalNumber, SolidityParserHexNumber, SolidityParserHexLiteralFragment, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserTypeKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier, SolidityParserStringLiteralFragment:
		{
			p.SetState(720)
			p.ExpressionStatement()
		}

	case SolidityParserT__1:
		{
			p.SetState(721)
			p.Match(SolidityParserT__1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-6)) & ^0x3f) == 0 && ((int64(1)<<(_la-6))&-72038554396917503) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&524744174868627459) != 0) {
		{
			p.SetState(724)
			p.expression(0)
		}

	}
	{
		p.SetState(727)
		p.Match(SolidityParserT__23)
	}
	{
		p.SetState(728)
		p.Statement()
	}

	return localctx
}

// IInlineAssemblyStatementContext is an interface to support dynamic dispatch.
type IInlineAssemblyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyBlock() IAssemblyBlockContext
	StringLiteralFragment() antlr.TerminalNode
	InlineAssemblyStatementFlag() IInlineAssemblyStatementFlagContext

	// IsInlineAssemblyStatementContext differentiates from other interfaces.
	IsInlineAssemblyStatementContext()
}

type InlineAssemblyStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineAssemblyStatementContext() *InlineAssemblyStatementContext {
	var p = new(InlineAssemblyStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_inlineAssemblyStatement
	return p
}

func (*InlineAssemblyStatementContext) IsInlineAssemblyStatementContext() {}

func NewInlineAssemblyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineAssemblyStatementContext {
	var p = new(InlineAssemblyStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_inlineAssemblyStatement

	return p
}

func (s *InlineAssemblyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineAssemblyStatementContext) AssemblyBlock() IAssemblyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *InlineAssemblyStatementContext) StringLiteralFragment() antlr.TerminalNode {
	return s.GetToken(SolidityParserStringLiteralFragment, 0)
}

func (s *InlineAssemblyStatementContext) InlineAssemblyStatementFlag() IInlineAssemblyStatementFlagContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineAssemblyStatementFlagContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineAssemblyStatementFlagContext)
}

func (s *InlineAssemblyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineAssemblyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineAssemblyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterInlineAssemblyStatement(s)
	}
}

func (s *InlineAssemblyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitInlineAssemblyStatement(s)
	}
}

func (p *SolidityParser) InlineAssemblyStatement() (localctx IInlineAssemblyStatementContext) {
	this := p
	_ = this

	localctx = NewInlineAssemblyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SolidityParserRULE_inlineAssemblyStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(730)
		p.Match(SolidityParserT__56)
	}
	p.SetState(732)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserStringLiteralFragment {
		{
			p.SetState(731)
			p.Match(SolidityParserStringLiteralFragment)
		}

	}
	p.SetState(738)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__22 {
		{
			p.SetState(734)
			p.Match(SolidityParserT__22)
		}
		{
			p.SetState(735)
			p.InlineAssemblyStatementFlag()
		}
		{
			p.SetState(736)
			p.Match(SolidityParserT__23)
		}

	}
	{
		p.SetState(740)
		p.AssemblyBlock()
	}

	return localctx
}

// IInlineAssemblyStatementFlagContext is an interface to support dynamic dispatch.
type IInlineAssemblyStatementFlagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext

	// IsInlineAssemblyStatementFlagContext differentiates from other interfaces.
	IsInlineAssemblyStatementFlagContext()
}

type InlineAssemblyStatementFlagContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineAssemblyStatementFlagContext() *InlineAssemblyStatementFlagContext {
	var p = new(InlineAssemblyStatementFlagContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_inlineAssemblyStatementFlag
	return p
}

func (*InlineAssemblyStatementFlagContext) IsInlineAssemblyStatementFlagContext() {}

func NewInlineAssemblyStatementFlagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineAssemblyStatementFlagContext {
	var p = new(InlineAssemblyStatementFlagContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_inlineAssemblyStatementFlag

	return p
}

func (s *InlineAssemblyStatementFlagContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineAssemblyStatementFlagContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *InlineAssemblyStatementFlagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineAssemblyStatementFlagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineAssemblyStatementFlagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterInlineAssemblyStatementFlag(s)
	}
}

func (s *InlineAssemblyStatementFlagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitInlineAssemblyStatementFlag(s)
	}
}

func (p *SolidityParser) InlineAssemblyStatementFlag() (localctx IInlineAssemblyStatementFlagContext) {
	this := p
	_ = this

	localctx = NewInlineAssemblyStatementFlagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SolidityParserRULE_inlineAssemblyStatementFlag)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(742)
		p.StringLiteral()
	}

	return localctx
}

// IDoWhileStatementContext is an interface to support dynamic dispatch.
type IDoWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	Expression() IExpressionContext

	// IsDoWhileStatementContext differentiates from other interfaces.
	IsDoWhileStatementContext()
}

type DoWhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoWhileStatementContext() *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_doWhileStatement
	return p
}

func (*DoWhileStatementContext) IsDoWhileStatementContext() {}

func NewDoWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_doWhileStatement

	return p
}

func (s *DoWhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoWhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoWhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DoWhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoWhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterDoWhileStatement(s)
	}
}

func (s *DoWhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitDoWhileStatement(s)
	}
}

func (p *SolidityParser) DoWhileStatement() (localctx IDoWhileStatementContext) {
	this := p
	_ = this

	localctx = NewDoWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SolidityParserRULE_doWhileStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(744)
		p.Match(SolidityParserT__57)
	}
	{
		p.SetState(745)
		p.Statement()
	}
	{
		p.SetState(746)
		p.Match(SolidityParserT__54)
	}
	{
		p.SetState(747)
		p.Match(SolidityParserT__22)
	}
	{
		p.SetState(748)
		p.expression(0)
	}
	{
		p.SetState(749)
		p.Match(SolidityParserT__23)
	}
	{
		p.SetState(750)
		p.Match(SolidityParserT__1)
	}

	return localctx
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ContinueKeyword() antlr.TerminalNode

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) ContinueKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserContinueKeyword, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (p *SolidityParser) ContinueStatement() (localctx IContinueStatementContext) {
	this := p
	_ = this

	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SolidityParserRULE_continueStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(752)
		p.Match(SolidityParserContinueKeyword)
	}
	{
		p.SetState(753)
		p.Match(SolidityParserT__1)
	}

	return localctx
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BreakKeyword() antlr.TerminalNode

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_breakStatement
	return p
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) BreakKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserBreakKeyword, 0)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (p *SolidityParser) BreakStatement() (localctx IBreakStatementContext) {
	this := p
	_ = this

	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SolidityParserRULE_breakStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(755)
		p.Match(SolidityParserBreakKeyword)
	}
	{
		p.SetState(756)
		p.Match(SolidityParserT__1)
	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (p *SolidityParser) ReturnStatement() (localctx IReturnStatementContext) {
	this := p
	_ = this

	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SolidityParserRULE_returnStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(758)
		p.Match(SolidityParserT__58)
	}
	p.SetState(760)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-6)) & ^0x3f) == 0 && ((int64(1)<<(_la-6))&-72038554396917503) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&524744174868627459) != 0) {
		{
			p.SetState(759)
			p.expression(0)
		}

	}
	{
		p.SetState(762)
		p.Match(SolidityParserT__1)
	}

	return localctx
}

// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_throwStatement
	return p
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }
func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterThrowStatement(s)
	}
}

func (s *ThrowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitThrowStatement(s)
	}
}

func (p *SolidityParser) ThrowStatement() (localctx IThrowStatementContext) {
	this := p
	_ = this

	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SolidityParserRULE_throwStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(764)
		p.Match(SolidityParserT__59)
	}
	{
		p.SetState(765)
		p.Match(SolidityParserT__1)
	}

	return localctx
}

// IEmitStatementContext is an interface to support dynamic dispatch.
type IEmitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionCall() IFunctionCallContext

	// IsEmitStatementContext differentiates from other interfaces.
	IsEmitStatementContext()
}

type EmitStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmitStatementContext() *EmitStatementContext {
	var p = new(EmitStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_emitStatement
	return p
}

func (*EmitStatementContext) IsEmitStatementContext() {}

func NewEmitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmitStatementContext {
	var p = new(EmitStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_emitStatement

	return p
}

func (s *EmitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EmitStatementContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *EmitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEmitStatement(s)
	}
}

func (s *EmitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEmitStatement(s)
	}
}

func (p *SolidityParser) EmitStatement() (localctx IEmitStatementContext) {
	this := p
	_ = this

	localctx = NewEmitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SolidityParserRULE_emitStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(767)
		p.Match(SolidityParserT__60)
	}
	{
		p.SetState(768)
		p.FunctionCall()
	}
	{
		p.SetState(769)
		p.Match(SolidityParserT__1)
	}

	return localctx
}

// IRevertStatementContext is an interface to support dynamic dispatch.
type IRevertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionCall() IFunctionCallContext

	// IsRevertStatementContext differentiates from other interfaces.
	IsRevertStatementContext()
}

type RevertStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevertStatementContext() *RevertStatementContext {
	var p = new(RevertStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_revertStatement
	return p
}

func (*RevertStatementContext) IsRevertStatementContext() {}

func NewRevertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevertStatementContext {
	var p = new(RevertStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_revertStatement

	return p
}

func (s *RevertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RevertStatementContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *RevertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RevertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterRevertStatement(s)
	}
}

func (s *RevertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitRevertStatement(s)
	}
}

func (p *SolidityParser) RevertStatement() (localctx IRevertStatementContext) {
	this := p
	_ = this

	localctx = NewRevertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SolidityParserRULE_revertStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(771)
		p.Match(SolidityParserT__61)
	}
	{
		p.SetState(772)
		p.FunctionCall()
	}
	{
		p.SetState(773)
		p.Match(SolidityParserT__1)
	}

	return localctx
}

// IVariableDeclarationStatementContext is an interface to support dynamic dispatch.
type IVariableDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	VariableDeclaration() IVariableDeclarationContext
	VariableDeclarationList() IVariableDeclarationListContext
	Expression() IExpressionContext

	// IsVariableDeclarationStatementContext differentiates from other interfaces.
	IsVariableDeclarationStatementContext()
}

type VariableDeclarationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationStatementContext() *VariableDeclarationStatementContext {
	var p = new(VariableDeclarationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclarationStatement
	return p
}

func (*VariableDeclarationStatementContext) IsVariableDeclarationStatementContext() {}

func NewVariableDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationStatementContext {
	var p = new(VariableDeclarationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_variableDeclarationStatement

	return p
}

func (s *VariableDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationStatementContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *VariableDeclarationStatementContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationStatementContext) VariableDeclarationList() IVariableDeclarationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationListContext)
}

func (s *VariableDeclarationStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVariableDeclarationStatement(s)
	}
}

func (s *VariableDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVariableDeclarationStatement(s)
	}
}

func (p *SolidityParser) VariableDeclarationStatement() (localctx IVariableDeclarationStatementContext) {
	this := p
	_ = this

	localctx = NewVariableDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SolidityParserRULE_variableDeclarationStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(782)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(775)
			p.Match(SolidityParserT__62)
		}
		{
			p.SetState(776)
			p.IdentifierList()
		}

	case 2:
		{
			p.SetState(777)
			p.VariableDeclaration()
		}

	case 3:
		{
			p.SetState(778)
			p.Match(SolidityParserT__22)
		}
		{
			p.SetState(779)
			p.VariableDeclarationList()
		}
		{
			p.SetState(780)
			p.Match(SolidityParserT__23)
		}

	}
	p.SetState(786)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__10 {
		{
			p.SetState(784)
			p.Match(SolidityParserT__10)
		}
		{
			p.SetState(785)
			p.expression(0)
		}

	}
	{
		p.SetState(788)
		p.Match(SolidityParserT__1)
	}

	return localctx
}

// IVariableDeclarationListContext is an interface to support dynamic dispatch.
type IVariableDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableDeclaration() []IVariableDeclarationContext
	VariableDeclaration(i int) IVariableDeclarationContext

	// IsVariableDeclarationListContext differentiates from other interfaces.
	IsVariableDeclarationListContext()
}

type VariableDeclarationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationListContext() *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclarationList
	return p
}

func (*VariableDeclarationListContext) IsVariableDeclarationListContext() {}

func NewVariableDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_variableDeclarationList

	return p
}

func (s *VariableDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationListContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationListContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVariableDeclarationList(s)
	}
}

func (s *VariableDeclarationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVariableDeclarationList(s)
	}
}

func (p *SolidityParser) VariableDeclarationList() (localctx IVariableDeclarationListContext) {
	this := p
	_ = this

	localctx = NewVariableDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SolidityParserRULE_variableDeclarationList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(791)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-14)) & ^0x3f) == 0 && ((int64(1)<<(_la-14))&8725798382995457) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100285) != 0) {
		{
			p.SetState(790)
			p.VariableDeclaration()
		}

	}
	p.SetState(799)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserT__15 {
		{
			p.SetState(793)
			p.Match(SolidityParserT__15)
		}
		p.SetState(795)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-14)) & ^0x3f) == 0 && ((int64(1)<<(_la-14))&8725798382995457) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100285) != 0) {
			{
				p.SetState(794)
				p.VariableDeclaration()
			}

		}

		p.SetState(801)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_identifierList
	return p
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (p *SolidityParser) IdentifierList() (localctx IIdentifierListContext) {
	this := p
	_ = this

	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SolidityParserRULE_identifierList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(802)
		p.Match(SolidityParserT__22)
	}
	p.SetState(809)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(804)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4612829510553845760) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100161) != 0) {
				{
					p.SetState(803)
					p.Identifier()
				}

			}
			{
				p.SetState(806)
				p.Match(SolidityParserT__15)
			}

		}
		p.SetState(811)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext())
	}
	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4612829510553845760) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100161) != 0) {
		{
			p.SetState(812)
			p.Identifier()
		}

	}
	{
		p.SetState(815)
		p.Match(SolidityParserT__23)
	}

	return localctx
}

// IElementaryTypeNameContext is an interface to support dynamic dispatch.
type IElementaryTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Int() antlr.TerminalNode
	Uint() antlr.TerminalNode
	Byte() antlr.TerminalNode
	Fixed() antlr.TerminalNode
	Ufixed() antlr.TerminalNode

	// IsElementaryTypeNameContext differentiates from other interfaces.
	IsElementaryTypeNameContext()
}

type ElementaryTypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementaryTypeNameContext() *ElementaryTypeNameContext {
	var p = new(ElementaryTypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_elementaryTypeName
	return p
}

func (*ElementaryTypeNameContext) IsElementaryTypeNameContext() {}

func NewElementaryTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementaryTypeNameContext {
	var p = new(ElementaryTypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_elementaryTypeName

	return p
}

func (s *ElementaryTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementaryTypeNameContext) Int() antlr.TerminalNode {
	return s.GetToken(SolidityParserInt, 0)
}

func (s *ElementaryTypeNameContext) Uint() antlr.TerminalNode {
	return s.GetToken(SolidityParserUint, 0)
}

func (s *ElementaryTypeNameContext) Byte() antlr.TerminalNode {
	return s.GetToken(SolidityParserByte, 0)
}

func (s *ElementaryTypeNameContext) Fixed() antlr.TerminalNode {
	return s.GetToken(SolidityParserFixed, 0)
}

func (s *ElementaryTypeNameContext) Ufixed() antlr.TerminalNode {
	return s.GetToken(SolidityParserUfixed, 0)
}

func (s *ElementaryTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementaryTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementaryTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterElementaryTypeName(s)
	}
}

func (s *ElementaryTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitElementaryTypeName(s)
	}
}

func (p *SolidityParser) ElementaryTypeName() (localctx IElementaryTypeNameContext) {
	this := p
	_ = this

	localctx = NewElementaryTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SolidityParserRULE_elementaryTypeName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(817)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&279223176904835073) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	PrimaryExpression() IPrimaryExpressionContext
	Identifier() IIdentifierContext
	NameValueList() INameValueListContext
	FunctionCallArguments() IFunctionCallArgumentsContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExpressionContext) NameValueList() INameValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameValueListContext)
}

func (s *ExpressionContext) FunctionCallArguments() IFunctionCallArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallArgumentsContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *SolidityParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *SolidityParser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 140
	p.EnterRecursionRule(localctx, 140, SolidityParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(837)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(820)
			p.Match(SolidityParserT__68)
		}
		{
			p.SetState(821)
			p.typeName(0)
		}

	case 2:
		{
			p.SetState(822)
			p.Match(SolidityParserT__22)
		}
		{
			p.SetState(823)
			p.expression(0)
		}
		{
			p.SetState(824)
			p.Match(SolidityParserT__23)
		}

	case 3:
		{
			p.SetState(826)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SolidityParserT__66 || _la == SolidityParserT__67) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(827)
			p.expression(19)
		}

	case 4:
		{
			p.SetState(828)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SolidityParserT__29 || _la == SolidityParserT__30) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(829)
			p.expression(18)
		}

	case 5:
		{
			p.SetState(830)
			p.Match(SolidityParserT__70)
		}
		{
			p.SetState(831)
			p.expression(17)
		}

	case 6:
		{
			p.SetState(832)
			p.Match(SolidityParserT__71)
		}
		{
			p.SetState(833)
			p.expression(16)
		}

	case 7:
		{
			p.SetState(834)
			p.Match(SolidityParserT__5)
		}
		{
			p.SetState(835)
			p.expression(15)
		}

	case 8:
		{
			p.SetState(836)
			p.PrimaryExpression()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(913)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(911)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(839)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(840)
					p.Match(SolidityParserT__72)
				}
				{
					p.SetState(841)
					p.expression(15)
				}

			case 2:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(842)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(843)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&12884901896) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(844)
					p.expression(14)
				}

			case 3:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(845)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(846)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserT__29 || _la == SolidityParserT__30) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(847)
					p.expression(13)
				}

			case 4:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(848)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(849)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserT__73 || _la == SolidityParserT__74) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(850)
					p.expression(12)
				}

			case 5:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(851)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(852)
					p.Match(SolidityParserT__28)
				}
				{
					p.SetState(853)
					p.expression(11)
				}

			case 6:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(854)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(855)
					p.Match(SolidityParserT__4)
				}
				{
					p.SetState(856)
					p.expression(10)
				}

			case 7:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(857)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(858)
					p.Match(SolidityParserT__27)
				}
				{
					p.SetState(859)
					p.expression(9)
				}

			case 8:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(860)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(861)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1920) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(862)
					p.expression(8)
				}

			case 9:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(863)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(864)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserT__33 || _la == SolidityParserT__34) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(865)
					p.expression(7)
				}

			case 10:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(866)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(867)
					p.Match(SolidityParserT__75)
				}
				{
					p.SetState(868)
					p.expression(6)
				}

			case 11:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(869)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(870)
					p.Match(SolidityParserT__3)
				}
				{
					p.SetState(871)
					p.expression(5)
				}

			case 12:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(872)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(873)
					p.Match(SolidityParserT__76)
				}
				{
					p.SetState(874)
					p.expression(0)
				}
				{
					p.SetState(875)
					p.Match(SolidityParserT__69)
				}
				{
					p.SetState(876)
					p.expression(4)
				}

			case 13:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(878)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(879)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserT__10 || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&1023) != 0)) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(880)
					p.expression(3)
				}

			case 14:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(881)

				if !(p.Precpred(p.GetParserRuleContext(), 27)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 27)", ""))
				}
				{
					p.SetState(882)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserT__66 || _la == SolidityParserT__67) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case 15:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(883)

				if !(p.Precpred(p.GetParserRuleContext(), 25)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 25)", ""))
				}
				{
					p.SetState(884)
					p.Match(SolidityParserT__41)
				}
				{
					p.SetState(885)
					p.expression(0)
				}
				{
					p.SetState(886)
					p.Match(SolidityParserT__42)
				}

			case 16:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(888)

				if !(p.Precpred(p.GetParserRuleContext(), 24)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 24)", ""))
				}
				{
					p.SetState(889)
					p.Match(SolidityParserT__41)
				}
				p.SetState(891)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if ((int64((_la-6)) & ^0x3f) == 0 && ((int64(1)<<(_la-6))&-72038554396917503) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&524744174868627459) != 0) {
					{
						p.SetState(890)
						p.expression(0)
					}

				}
				{
					p.SetState(893)
					p.Match(SolidityParserT__69)
				}
				p.SetState(895)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if ((int64((_la-6)) & ^0x3f) == 0 && ((int64(1)<<(_la-6))&-72038554396917503) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&524744174868627459) != 0) {
					{
						p.SetState(894)
						p.expression(0)
					}

				}
				{
					p.SetState(897)
					p.Match(SolidityParserT__42)
				}

			case 17:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(898)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
				}
				{
					p.SetState(899)
					p.Match(SolidityParserT__44)
				}
				{
					p.SetState(900)
					p.Identifier()
				}

			case 18:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(901)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
				}
				{
					p.SetState(902)
					p.Match(SolidityParserT__14)
				}
				{
					p.SetState(903)
					p.NameValueList()
				}
				{
					p.SetState(904)
					p.Match(SolidityParserT__16)
				}

			case 19:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(906)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
				}
				{
					p.SetState(907)
					p.Match(SolidityParserT__22)
				}
				{
					p.SetState(908)
					p.FunctionCallArguments()
				}
				{
					p.SetState(909)
					p.Match(SolidityParserT__23)
				}

			}

		}
		p.SetState(915)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext())
	}

	return localctx
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BooleanLiteral() antlr.TerminalNode
	NumberLiteral() INumberLiteralContext
	HexLiteral() IHexLiteralContext
	StringLiteral() IStringLiteralContext
	Identifier() IIdentifierContext
	TypeKeyword() antlr.TerminalNode
	PayableKeyword() antlr.TerminalNode
	TupleExpression() ITupleExpressionContext
	TypeName() ITypeNameContext

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_primaryExpression
	return p
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(SolidityParserBooleanLiteral, 0)
}

func (s *PrimaryExpressionContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *PrimaryExpressionContext) HexLiteral() IHexLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexLiteralContext)
}

func (s *PrimaryExpressionContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PrimaryExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrimaryExpressionContext) TypeKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserTypeKeyword, 0)
}

func (s *PrimaryExpressionContext) PayableKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserPayableKeyword, 0)
}

func (s *PrimaryExpressionContext) TupleExpression() ITupleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleExpressionContext)
}

func (s *PrimaryExpressionContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitPrimaryExpression(s)
	}
}

func (p *SolidityParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	this := p
	_ = this

	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SolidityParserRULE_primaryExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(925)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(916)
			p.Match(SolidityParserBooleanLiteral)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(917)
			p.NumberLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(918)
			p.HexLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(919)
			p.StringLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(920)
			p.Identifier()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(921)
			p.Match(SolidityParserTypeKeyword)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(922)
			p.Match(SolidityParserPayableKeyword)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(923)
			p.TupleExpression()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(924)
			p.typeName(0)
		}

	}

	return localctx
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_expressionList
	return p
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (p *SolidityParser) ExpressionList() (localctx IExpressionListContext) {
	this := p
	_ = this

	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SolidityParserRULE_expressionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(927)
		p.expression(0)
	}
	p.SetState(932)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserT__15 {
		{
			p.SetState(928)
			p.Match(SolidityParserT__15)
		}
		{
			p.SetState(929)
			p.expression(0)
		}

		p.SetState(934)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// INameValueListContext is an interface to support dynamic dispatch.
type INameValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNameValue() []INameValueContext
	NameValue(i int) INameValueContext

	// IsNameValueListContext differentiates from other interfaces.
	IsNameValueListContext()
}

type NameValueListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameValueListContext() *NameValueListContext {
	var p = new(NameValueListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_nameValueList
	return p
}

func (*NameValueListContext) IsNameValueListContext() {}

func NewNameValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameValueListContext {
	var p = new(NameValueListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_nameValueList

	return p
}

func (s *NameValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *NameValueListContext) AllNameValue() []INameValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameValueContext); ok {
			len++
		}
	}

	tst := make([]INameValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameValueContext); ok {
			tst[i] = t.(INameValueContext)
			i++
		}
	}

	return tst
}

func (s *NameValueListContext) NameValue(i int) INameValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameValueContext)
}

func (s *NameValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterNameValueList(s)
	}
}

func (s *NameValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitNameValueList(s)
	}
}

func (p *SolidityParser) NameValueList() (localctx INameValueListContext) {
	this := p
	_ = this

	localctx = NewNameValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SolidityParserRULE_nameValueList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(935)
		p.NameValue()
	}
	p.SetState(940)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(936)
				p.Match(SolidityParserT__15)
			}
			{
				p.SetState(937)
				p.NameValue()
			}

		}
		p.SetState(942)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())
	}
	p.SetState(944)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__15 {
		{
			p.SetState(943)
			p.Match(SolidityParserT__15)
		}

	}

	return localctx
}

// INameValueContext is an interface to support dynamic dispatch.
type INameValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Expression() IExpressionContext

	// IsNameValueContext differentiates from other interfaces.
	IsNameValueContext()
}

type NameValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameValueContext() *NameValueContext {
	var p = new(NameValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_nameValue
	return p
}

func (*NameValueContext) IsNameValueContext() {}

func NewNameValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameValueContext {
	var p = new(NameValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_nameValue

	return p
}

func (s *NameValueContext) GetParser() antlr.Parser { return s.parser }

func (s *NameValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NameValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NameValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterNameValue(s)
	}
}

func (s *NameValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitNameValue(s)
	}
}

func (p *SolidityParser) NameValue() (localctx INameValueContext) {
	this := p
	_ = this

	localctx = NewNameValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SolidityParserRULE_nameValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(946)
		p.Identifier()
	}
	{
		p.SetState(947)
		p.Match(SolidityParserT__69)
	}
	{
		p.SetState(948)
		p.expression(0)
	}

	return localctx
}

// IFunctionCallArgumentsContext is an interface to support dynamic dispatch.
type IFunctionCallArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NameValueList() INameValueListContext
	ExpressionList() IExpressionListContext

	// IsFunctionCallArgumentsContext differentiates from other interfaces.
	IsFunctionCallArgumentsContext()
}

type FunctionCallArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallArgumentsContext() *FunctionCallArgumentsContext {
	var p = new(FunctionCallArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_functionCallArguments
	return p
}

func (*FunctionCallArgumentsContext) IsFunctionCallArgumentsContext() {}

func NewFunctionCallArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallArgumentsContext {
	var p = new(FunctionCallArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionCallArguments

	return p
}

func (s *FunctionCallArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallArgumentsContext) NameValueList() INameValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameValueListContext)
}

func (s *FunctionCallArgumentsContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *FunctionCallArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionCallArguments(s)
	}
}

func (s *FunctionCallArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionCallArguments(s)
	}
}

func (p *SolidityParser) FunctionCallArguments() (localctx IFunctionCallArgumentsContext) {
	this := p
	_ = this

	localctx = NewFunctionCallArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SolidityParserRULE_functionCallArguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(958)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__14:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(950)
			p.Match(SolidityParserT__14)
		}
		p.SetState(952)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4612829510553845760) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100161) != 0) {
			{
				p.SetState(951)
				p.NameValueList()
			}

		}
		{
			p.SetState(954)
			p.Match(SolidityParserT__16)
		}

	case SolidityParserT__5, SolidityParserT__13, SolidityParserT__22, SolidityParserT__23, SolidityParserT__24, SolidityParserT__29, SolidityParserT__30, SolidityParserT__37, SolidityParserT__41, SolidityParserT__43, SolidityParserT__45, SolidityParserT__49, SolidityParserT__61, SolidityParserT__62, SolidityParserT__63, SolidityParserT__64, SolidityParserT__65, SolidityParserT__66, SolidityParserT__67, SolidityParserT__68, SolidityParserT__70, SolidityParserT__71, SolidityParserT__94, SolidityParserInt, SolidityParserUint, SolidityParserByte, SolidityParserFixed, SolidityParserUfixed, SolidityParserBooleanLiteral, SolidityParserDecimalNumber, SolidityParserHexNumber, SolidityParserHexLiteralFragment, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserTypeKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier, SolidityParserStringLiteralFragment:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(956)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-6)) & ^0x3f) == 0 && ((int64(1)<<(_la-6))&-72038554396917503) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&524744174868627459) != 0) {
			{
				p.SetState(955)
				p.ExpressionList()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	FunctionCallArguments() IFunctionCallArgumentsContext

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_functionCall
	return p
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallContext) FunctionCallArguments() IFunctionCallArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallArgumentsContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (p *SolidityParser) FunctionCall() (localctx IFunctionCallContext) {
	this := p
	_ = this

	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SolidityParserRULE_functionCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(960)
		p.expression(0)
	}
	{
		p.SetState(961)
		p.Match(SolidityParserT__22)
	}
	{
		p.SetState(962)
		p.FunctionCallArguments()
	}
	{
		p.SetState(963)
		p.Match(SolidityParserT__23)
	}

	return localctx
}

// IAssemblyBlockContext is an interface to support dynamic dispatch.
type IAssemblyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssemblyItem() []IAssemblyItemContext
	AssemblyItem(i int) IAssemblyItemContext

	// IsAssemblyBlockContext differentiates from other interfaces.
	IsAssemblyBlockContext()
}

type AssemblyBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyBlockContext() *AssemblyBlockContext {
	var p = new(AssemblyBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyBlock
	return p
}

func (*AssemblyBlockContext) IsAssemblyBlockContext() {}

func NewAssemblyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyBlockContext {
	var p = new(AssemblyBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyBlock

	return p
}

func (s *AssemblyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyBlockContext) AllAssemblyItem() []IAssemblyItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssemblyItemContext); ok {
			len++
		}
	}

	tst := make([]IAssemblyItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssemblyItemContext); ok {
			tst[i] = t.(IAssemblyItemContext)
			i++
		}
	}

	return tst
}

func (s *AssemblyBlockContext) AssemblyItem(i int) IAssemblyItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyItemContext)
}

func (s *AssemblyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyBlock(s)
	}
}

func (s *AssemblyBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyBlock(s)
	}
}

func (p *SolidityParser) AssemblyBlock() (localctx IAssemblyBlockContext) {
	this := p
	_ = this

	localctx = NewAssemblyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SolidityParserRULE_assemblyBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(965)
		p.Match(SolidityParserT__14)
	}
	p.SetState(969)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&5191542337691500544) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-1726908973648445439) != 0) {
		{
			p.SetState(966)
			p.AssemblyItem()
		}

		p.SetState(971)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(972)
		p.Match(SolidityParserT__16)
	}

	return localctx
}

// IAssemblyItemContext is an interface to support dynamic dispatch.
type IAssemblyItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AssemblyBlock() IAssemblyBlockContext
	AssemblyExpression() IAssemblyExpressionContext
	AssemblyLocalDefinition() IAssemblyLocalDefinitionContext
	AssemblyAssignment() IAssemblyAssignmentContext
	AssemblyStackAssignment() IAssemblyStackAssignmentContext
	LabelDefinition() ILabelDefinitionContext
	AssemblySwitch() IAssemblySwitchContext
	AssemblyFunctionDefinition() IAssemblyFunctionDefinitionContext
	AssemblyFor() IAssemblyForContext
	AssemblyIf() IAssemblyIfContext
	BreakKeyword() antlr.TerminalNode
	ContinueKeyword() antlr.TerminalNode
	LeaveKeyword() antlr.TerminalNode
	NumberLiteral() INumberLiteralContext
	StringLiteral() IStringLiteralContext
	HexLiteral() IHexLiteralContext

	// IsAssemblyItemContext differentiates from other interfaces.
	IsAssemblyItemContext()
}

type AssemblyItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyItemContext() *AssemblyItemContext {
	var p = new(AssemblyItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyItem
	return p
}

func (*AssemblyItemContext) IsAssemblyItemContext() {}

func NewAssemblyItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyItemContext {
	var p = new(AssemblyItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyItem

	return p
}

func (s *AssemblyItemContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyItemContext) AssemblyBlock() IAssemblyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *AssemblyItemContext) AssemblyExpression() IAssemblyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyItemContext) AssemblyLocalDefinition() IAssemblyLocalDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyLocalDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyLocalDefinitionContext)
}

func (s *AssemblyItemContext) AssemblyAssignment() IAssemblyAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyAssignmentContext)
}

func (s *AssemblyItemContext) AssemblyStackAssignment() IAssemblyStackAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyStackAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyStackAssignmentContext)
}

func (s *AssemblyItemContext) LabelDefinition() ILabelDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDefinitionContext)
}

func (s *AssemblyItemContext) AssemblySwitch() IAssemblySwitchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblySwitchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblySwitchContext)
}

func (s *AssemblyItemContext) AssemblyFunctionDefinition() IAssemblyFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyFunctionDefinitionContext)
}

func (s *AssemblyItemContext) AssemblyFor() IAssemblyForContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyForContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyForContext)
}

func (s *AssemblyItemContext) AssemblyIf() IAssemblyIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyIfContext)
}

func (s *AssemblyItemContext) BreakKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserBreakKeyword, 0)
}

func (s *AssemblyItemContext) ContinueKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserContinueKeyword, 0)
}

func (s *AssemblyItemContext) LeaveKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserLeaveKeyword, 0)
}

func (s *AssemblyItemContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *AssemblyItemContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AssemblyItemContext) HexLiteral() IHexLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexLiteralContext)
}

func (s *AssemblyItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyItem(s)
	}
}

func (s *AssemblyItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyItem(s)
	}
}

func (p *SolidityParser) AssemblyItem() (localctx IAssemblyItemContext) {
	this := p
	_ = this

	localctx = NewAssemblyItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SolidityParserRULE_assemblyItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(991)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(974)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(975)
			p.AssemblyBlock()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(976)
			p.AssemblyExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(977)
			p.AssemblyLocalDefinition()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(978)
			p.AssemblyAssignment()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(979)
			p.AssemblyStackAssignment()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(980)
			p.LabelDefinition()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(981)
			p.AssemblySwitch()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(982)
			p.AssemblyFunctionDefinition()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(983)
			p.AssemblyFor()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(984)
			p.AssemblyIf()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(985)
			p.Match(SolidityParserBreakKeyword)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(986)
			p.Match(SolidityParserContinueKeyword)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(987)
			p.Match(SolidityParserLeaveKeyword)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(988)
			p.NumberLiteral()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(989)
			p.StringLiteral()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(990)
			p.HexLiteral()
		}

	}

	return localctx
}

// IAssemblyExpressionContext is an interface to support dynamic dispatch.
type IAssemblyExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyCall() IAssemblyCallContext
	AssemblyLiteral() IAssemblyLiteralContext
	AssemblyMember() IAssemblyMemberContext

	// IsAssemblyExpressionContext differentiates from other interfaces.
	IsAssemblyExpressionContext()
}

type AssemblyExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyExpressionContext() *AssemblyExpressionContext {
	var p = new(AssemblyExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyExpression
	return p
}

func (*AssemblyExpressionContext) IsAssemblyExpressionContext() {}

func NewAssemblyExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyExpressionContext {
	var p = new(AssemblyExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyExpression

	return p
}

func (s *AssemblyExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyExpressionContext) AssemblyCall() IAssemblyCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyCallContext)
}

func (s *AssemblyExpressionContext) AssemblyLiteral() IAssemblyLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyLiteralContext)
}

func (s *AssemblyExpressionContext) AssemblyMember() IAssemblyMemberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyMemberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyMemberContext)
}

func (s *AssemblyExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyExpression(s)
	}
}

func (s *AssemblyExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyExpression(s)
	}
}

func (p *SolidityParser) AssemblyExpression() (localctx IAssemblyExpressionContext) {
	this := p
	_ = this

	localctx = NewAssemblyExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SolidityParserRULE_assemblyExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(996)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(993)
			p.AssemblyCall()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(994)
			p.AssemblyLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(995)
			p.AssemblyMember()
		}

	}

	return localctx
}

// IAssemblyMemberContext is an interface to support dynamic dispatch.
type IAssemblyMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsAssemblyMemberContext differentiates from other interfaces.
	IsAssemblyMemberContext()
}

type AssemblyMemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyMemberContext() *AssemblyMemberContext {
	var p = new(AssemblyMemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyMember
	return p
}

func (*AssemblyMemberContext) IsAssemblyMemberContext() {}

func NewAssemblyMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyMemberContext {
	var p = new(AssemblyMemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyMember

	return p
}

func (s *AssemblyMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyMemberContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AssemblyMemberContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyMember(s)
	}
}

func (s *AssemblyMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyMember(s)
	}
}

func (p *SolidityParser) AssemblyMember() (localctx IAssemblyMemberContext) {
	this := p
	_ = this

	localctx = NewAssemblyMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SolidityParserRULE_assemblyMember)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(998)
		p.Identifier()
	}
	{
		p.SetState(999)
		p.Match(SolidityParserT__44)
	}
	{
		p.SetState(1000)
		p.Identifier()
	}

	return localctx
}

// IAssemblyCallContext is an interface to support dynamic dispatch.
type IAssemblyCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllAssemblyExpression() []IAssemblyExpressionContext
	AssemblyExpression(i int) IAssemblyExpressionContext

	// IsAssemblyCallContext differentiates from other interfaces.
	IsAssemblyCallContext()
}

type AssemblyCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyCallContext() *AssemblyCallContext {
	var p = new(AssemblyCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyCall
	return p
}

func (*AssemblyCallContext) IsAssemblyCallContext() {}

func NewAssemblyCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyCallContext {
	var p = new(AssemblyCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyCall

	return p
}

func (s *AssemblyCallContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyCallContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyCallContext) AllAssemblyExpression() []IAssemblyExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAssemblyExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssemblyExpressionContext); ok {
			tst[i] = t.(IAssemblyExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssemblyCallContext) AssemblyExpression(i int) IAssemblyExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyCall(s)
	}
}

func (s *AssemblyCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyCall(s)
	}
}

func (p *SolidityParser) AssemblyCall() (localctx IAssemblyCallContext) {
	this := p
	_ = this

	localctx = NewAssemblyCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SolidityParserRULE_assemblyCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1006)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1002)
			p.Match(SolidityParserT__58)
		}

	case 2:
		{
			p.SetState(1003)
			p.Match(SolidityParserT__43)
		}

	case 3:
		{
			p.SetState(1004)
			p.Match(SolidityParserT__65)
		}

	case 4:
		{
			p.SetState(1005)
			p.Identifier()
		}

	}
	p.SetState(1020)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1008)
			p.Match(SolidityParserT__22)
		}
		p.SetState(1010)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&5189290262857269248) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-1726988138523394047) != 0) {
			{
				p.SetState(1009)
				p.AssemblyExpression()
			}

		}
		p.SetState(1016)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserT__15 {
			{
				p.SetState(1012)
				p.Match(SolidityParserT__15)
			}
			{
				p.SetState(1013)
				p.AssemblyExpression()
			}

			p.SetState(1018)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1019)
			p.Match(SolidityParserT__23)
		}

	}

	return localctx
}

// IAssemblyLocalDefinitionContext is an interface to support dynamic dispatch.
type IAssemblyLocalDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyIdentifierOrList() IAssemblyIdentifierOrListContext
	AssemblyExpression() IAssemblyExpressionContext

	// IsAssemblyLocalDefinitionContext differentiates from other interfaces.
	IsAssemblyLocalDefinitionContext()
}

type AssemblyLocalDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyLocalDefinitionContext() *AssemblyLocalDefinitionContext {
	var p = new(AssemblyLocalDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyLocalDefinition
	return p
}

func (*AssemblyLocalDefinitionContext) IsAssemblyLocalDefinitionContext() {}

func NewAssemblyLocalDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyLocalDefinitionContext {
	var p = new(AssemblyLocalDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyLocalDefinition

	return p
}

func (s *AssemblyLocalDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyLocalDefinitionContext) AssemblyIdentifierOrList() IAssemblyIdentifierOrListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyIdentifierOrListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyIdentifierOrListContext)
}

func (s *AssemblyLocalDefinitionContext) AssemblyExpression() IAssemblyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyLocalDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyLocalDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyLocalDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyLocalDefinition(s)
	}
}

func (s *AssemblyLocalDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyLocalDefinition(s)
	}
}

func (p *SolidityParser) AssemblyLocalDefinition() (localctx IAssemblyLocalDefinitionContext) {
	this := p
	_ = this

	localctx = NewAssemblyLocalDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SolidityParserRULE_assemblyLocalDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1022)
		p.Match(SolidityParserT__87)
	}
	{
		p.SetState(1023)
		p.AssemblyIdentifierOrList()
	}
	p.SetState(1026)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__88 {
		{
			p.SetState(1024)
			p.Match(SolidityParserT__88)
		}
		{
			p.SetState(1025)
			p.AssemblyExpression()
		}

	}

	return localctx
}

// IAssemblyAssignmentContext is an interface to support dynamic dispatch.
type IAssemblyAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyIdentifierOrList() IAssemblyIdentifierOrListContext
	AssemblyExpression() IAssemblyExpressionContext

	// IsAssemblyAssignmentContext differentiates from other interfaces.
	IsAssemblyAssignmentContext()
}

type AssemblyAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyAssignmentContext() *AssemblyAssignmentContext {
	var p = new(AssemblyAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyAssignment
	return p
}

func (*AssemblyAssignmentContext) IsAssemblyAssignmentContext() {}

func NewAssemblyAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyAssignmentContext {
	var p = new(AssemblyAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyAssignment

	return p
}

func (s *AssemblyAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyAssignmentContext) AssemblyIdentifierOrList() IAssemblyIdentifierOrListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyIdentifierOrListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyIdentifierOrListContext)
}

func (s *AssemblyAssignmentContext) AssemblyExpression() IAssemblyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyAssignment(s)
	}
}

func (s *AssemblyAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyAssignment(s)
	}
}

func (p *SolidityParser) AssemblyAssignment() (localctx IAssemblyAssignmentContext) {
	this := p
	_ = this

	localctx = NewAssemblyAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SolidityParserRULE_assemblyAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1028)
		p.AssemblyIdentifierOrList()
	}
	{
		p.SetState(1029)
		p.Match(SolidityParserT__88)
	}
	{
		p.SetState(1030)
		p.AssemblyExpression()
	}

	return localctx
}

// IAssemblyIdentifierOrListContext is an interface to support dynamic dispatch.
type IAssemblyIdentifierOrListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AssemblyMember() IAssemblyMemberContext
	AssemblyIdentifierList() IAssemblyIdentifierListContext

	// IsAssemblyIdentifierOrListContext differentiates from other interfaces.
	IsAssemblyIdentifierOrListContext()
}

type AssemblyIdentifierOrListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyIdentifierOrListContext() *AssemblyIdentifierOrListContext {
	var p = new(AssemblyIdentifierOrListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyIdentifierOrList
	return p
}

func (*AssemblyIdentifierOrListContext) IsAssemblyIdentifierOrListContext() {}

func NewAssemblyIdentifierOrListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyIdentifierOrListContext {
	var p = new(AssemblyIdentifierOrListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyIdentifierOrList

	return p
}

func (s *AssemblyIdentifierOrListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyIdentifierOrListContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyIdentifierOrListContext) AssemblyMember() IAssemblyMemberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyMemberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyMemberContext)
}

func (s *AssemblyIdentifierOrListContext) AssemblyIdentifierList() IAssemblyIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyIdentifierListContext)
}

func (s *AssemblyIdentifierOrListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyIdentifierOrListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyIdentifierOrListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyIdentifierOrList(s)
	}
}

func (s *AssemblyIdentifierOrListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyIdentifierOrList(s)
	}
}

func (p *SolidityParser) AssemblyIdentifierOrList() (localctx IAssemblyIdentifierOrListContext) {
	this := p
	_ = this

	localctx = NewAssemblyIdentifierOrListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SolidityParserRULE_assemblyIdentifierOrList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1039)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1032)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1033)
			p.AssemblyMember()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1034)
			p.AssemblyIdentifierList()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1035)
			p.Match(SolidityParserT__22)
		}
		{
			p.SetState(1036)
			p.AssemblyIdentifierList()
		}
		{
			p.SetState(1037)
			p.Match(SolidityParserT__23)
		}

	}

	return localctx
}

// IAssemblyIdentifierListContext is an interface to support dynamic dispatch.
type IAssemblyIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsAssemblyIdentifierListContext differentiates from other interfaces.
	IsAssemblyIdentifierListContext()
}

type AssemblyIdentifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyIdentifierListContext() *AssemblyIdentifierListContext {
	var p = new(AssemblyIdentifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyIdentifierList
	return p
}

func (*AssemblyIdentifierListContext) IsAssemblyIdentifierListContext() {}

func NewAssemblyIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyIdentifierListContext {
	var p = new(AssemblyIdentifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyIdentifierList

	return p
}

func (s *AssemblyIdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyIdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AssemblyIdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyIdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyIdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyIdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyIdentifierList(s)
	}
}

func (s *AssemblyIdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyIdentifierList(s)
	}
}

func (p *SolidityParser) AssemblyIdentifierList() (localctx IAssemblyIdentifierListContext) {
	this := p
	_ = this

	localctx = NewAssemblyIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SolidityParserRULE_assemblyIdentifierList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1041)
		p.Identifier()
	}
	p.SetState(1046)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserT__15 {
		{
			p.SetState(1042)
			p.Match(SolidityParserT__15)
		}
		{
			p.SetState(1043)
			p.Identifier()
		}

		p.SetState(1048)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAssemblyStackAssignmentContext is an interface to support dynamic dispatch.
type IAssemblyStackAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyExpression() IAssemblyExpressionContext
	Identifier() IIdentifierContext

	// IsAssemblyStackAssignmentContext differentiates from other interfaces.
	IsAssemblyStackAssignmentContext()
}

type AssemblyStackAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyStackAssignmentContext() *AssemblyStackAssignmentContext {
	var p = new(AssemblyStackAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyStackAssignment
	return p
}

func (*AssemblyStackAssignmentContext) IsAssemblyStackAssignmentContext() {}

func NewAssemblyStackAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyStackAssignmentContext {
	var p = new(AssemblyStackAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyStackAssignment

	return p
}

func (s *AssemblyStackAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyStackAssignmentContext) AssemblyExpression() IAssemblyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyStackAssignmentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyStackAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyStackAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyStackAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyStackAssignment(s)
	}
}

func (s *AssemblyStackAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyStackAssignment(s)
	}
}

func (p *SolidityParser) AssemblyStackAssignment() (localctx IAssemblyStackAssignmentContext) {
	this := p
	_ = this

	localctx = NewAssemblyStackAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SolidityParserRULE_assemblyStackAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1049)
		p.AssemblyExpression()
	}
	{
		p.SetState(1050)
		p.Match(SolidityParserT__89)
	}
	{
		p.SetState(1051)
		p.Identifier()
	}

	return localctx
}

// ILabelDefinitionContext is an interface to support dynamic dispatch.
type ILabelDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsLabelDefinitionContext differentiates from other interfaces.
	IsLabelDefinitionContext()
}

type LabelDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelDefinitionContext() *LabelDefinitionContext {
	var p = new(LabelDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_labelDefinition
	return p
}

func (*LabelDefinitionContext) IsLabelDefinitionContext() {}

func NewLabelDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelDefinitionContext {
	var p = new(LabelDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_labelDefinition

	return p
}

func (s *LabelDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabelDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterLabelDefinition(s)
	}
}

func (s *LabelDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitLabelDefinition(s)
	}
}

func (p *SolidityParser) LabelDefinition() (localctx ILabelDefinitionContext) {
	this := p
	_ = this

	localctx = NewLabelDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SolidityParserRULE_labelDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1053)
		p.Identifier()
	}
	{
		p.SetState(1054)
		p.Match(SolidityParserT__69)
	}

	return localctx
}

// IAssemblySwitchContext is an interface to support dynamic dispatch.
type IAssemblySwitchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyExpression() IAssemblyExpressionContext
	AllAssemblyCase() []IAssemblyCaseContext
	AssemblyCase(i int) IAssemblyCaseContext

	// IsAssemblySwitchContext differentiates from other interfaces.
	IsAssemblySwitchContext()
}

type AssemblySwitchContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblySwitchContext() *AssemblySwitchContext {
	var p = new(AssemblySwitchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblySwitch
	return p
}

func (*AssemblySwitchContext) IsAssemblySwitchContext() {}

func NewAssemblySwitchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblySwitchContext {
	var p = new(AssemblySwitchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblySwitch

	return p
}

func (s *AssemblySwitchContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblySwitchContext) AssemblyExpression() IAssemblyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblySwitchContext) AllAssemblyCase() []IAssemblyCaseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssemblyCaseContext); ok {
			len++
		}
	}

	tst := make([]IAssemblyCaseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssemblyCaseContext); ok {
			tst[i] = t.(IAssemblyCaseContext)
			i++
		}
	}

	return tst
}

func (s *AssemblySwitchContext) AssemblyCase(i int) IAssemblyCaseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyCaseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyCaseContext)
}

func (s *AssemblySwitchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblySwitchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblySwitchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblySwitch(s)
	}
}

func (s *AssemblySwitchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblySwitch(s)
	}
}

func (p *SolidityParser) AssemblySwitch() (localctx IAssemblySwitchContext) {
	this := p
	_ = this

	localctx = NewAssemblySwitchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SolidityParserRULE_assemblySwitch)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1056)
		p.Match(SolidityParserT__90)
	}
	{
		p.SetState(1057)
		p.AssemblyExpression()
	}
	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserT__91 || _la == SolidityParserT__92 {
		{
			p.SetState(1058)
			p.AssemblyCase()
		}

		p.SetState(1063)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAssemblyCaseContext is an interface to support dynamic dispatch.
type IAssemblyCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyLiteral() IAssemblyLiteralContext
	AssemblyBlock() IAssemblyBlockContext

	// IsAssemblyCaseContext differentiates from other interfaces.
	IsAssemblyCaseContext()
}

type AssemblyCaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyCaseContext() *AssemblyCaseContext {
	var p = new(AssemblyCaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyCase
	return p
}

func (*AssemblyCaseContext) IsAssemblyCaseContext() {}

func NewAssemblyCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyCaseContext {
	var p = new(AssemblyCaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyCase

	return p
}

func (s *AssemblyCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyCaseContext) AssemblyLiteral() IAssemblyLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyLiteralContext)
}

func (s *AssemblyCaseContext) AssemblyBlock() IAssemblyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *AssemblyCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyCase(s)
	}
}

func (s *AssemblyCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyCase(s)
	}
}

func (p *SolidityParser) AssemblyCase() (localctx IAssemblyCaseContext) {
	this := p
	_ = this

	localctx = NewAssemblyCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SolidityParserRULE_assemblyCase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1070)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__91:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1064)
			p.Match(SolidityParserT__91)
		}
		{
			p.SetState(1065)
			p.AssemblyLiteral()
		}
		{
			p.SetState(1066)
			p.AssemblyBlock()
		}

	case SolidityParserT__92:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1068)
			p.Match(SolidityParserT__92)
		}
		{
			p.SetState(1069)
			p.AssemblyBlock()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAssemblyFunctionDefinitionContext is an interface to support dynamic dispatch.
type IAssemblyFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AssemblyBlock() IAssemblyBlockContext
	AssemblyIdentifierList() IAssemblyIdentifierListContext
	AssemblyFunctionReturns() IAssemblyFunctionReturnsContext

	// IsAssemblyFunctionDefinitionContext differentiates from other interfaces.
	IsAssemblyFunctionDefinitionContext()
}

type AssemblyFunctionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyFunctionDefinitionContext() *AssemblyFunctionDefinitionContext {
	var p = new(AssemblyFunctionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyFunctionDefinition
	return p
}

func (*AssemblyFunctionDefinitionContext) IsAssemblyFunctionDefinitionContext() {}

func NewAssemblyFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyFunctionDefinitionContext {
	var p = new(AssemblyFunctionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyFunctionDefinition

	return p
}

func (s *AssemblyFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyFunctionDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyFunctionDefinitionContext) AssemblyBlock() IAssemblyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *AssemblyFunctionDefinitionContext) AssemblyIdentifierList() IAssemblyIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyIdentifierListContext)
}

func (s *AssemblyFunctionDefinitionContext) AssemblyFunctionReturns() IAssemblyFunctionReturnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyFunctionReturnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyFunctionReturnsContext)
}

func (s *AssemblyFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyFunctionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyFunctionDefinition(s)
	}
}

func (s *AssemblyFunctionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyFunctionDefinition(s)
	}
}

func (p *SolidityParser) AssemblyFunctionDefinition() (localctx IAssemblyFunctionDefinitionContext) {
	this := p
	_ = this

	localctx = NewAssemblyFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SolidityParserRULE_assemblyFunctionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1072)
		p.Match(SolidityParserT__37)
	}
	{
		p.SetState(1073)
		p.Identifier()
	}
	{
		p.SetState(1074)
		p.Match(SolidityParserT__22)
	}
	p.SetState(1076)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4612829510553845760) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100161) != 0) {
		{
			p.SetState(1075)
			p.AssemblyIdentifierList()
		}

	}
	{
		p.SetState(1078)
		p.Match(SolidityParserT__23)
	}
	p.SetState(1080)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__93 {
		{
			p.SetState(1079)
			p.AssemblyFunctionReturns()
		}

	}
	{
		p.SetState(1082)
		p.AssemblyBlock()
	}

	return localctx
}

// IAssemblyFunctionReturnsContext is an interface to support dynamic dispatch.
type IAssemblyFunctionReturnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyIdentifierList() IAssemblyIdentifierListContext

	// IsAssemblyFunctionReturnsContext differentiates from other interfaces.
	IsAssemblyFunctionReturnsContext()
}

type AssemblyFunctionReturnsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyFunctionReturnsContext() *AssemblyFunctionReturnsContext {
	var p = new(AssemblyFunctionReturnsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyFunctionReturns
	return p
}

func (*AssemblyFunctionReturnsContext) IsAssemblyFunctionReturnsContext() {}

func NewAssemblyFunctionReturnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyFunctionReturnsContext {
	var p = new(AssemblyFunctionReturnsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyFunctionReturns

	return p
}

func (s *AssemblyFunctionReturnsContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyFunctionReturnsContext) AssemblyIdentifierList() IAssemblyIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyIdentifierListContext)
}

func (s *AssemblyFunctionReturnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyFunctionReturnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyFunctionReturnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyFunctionReturns(s)
	}
}

func (s *AssemblyFunctionReturnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyFunctionReturns(s)
	}
}

func (p *SolidityParser) AssemblyFunctionReturns() (localctx IAssemblyFunctionReturnsContext) {
	this := p
	_ = this

	localctx = NewAssemblyFunctionReturnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SolidityParserRULE_assemblyFunctionReturns)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1084)
		p.Match(SolidityParserT__93)
	}
	{
		p.SetState(1085)
		p.AssemblyIdentifierList()
	}

	return localctx
}

// IAssemblyForContext is an interface to support dynamic dispatch.
type IAssemblyForContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssemblyExpression() []IAssemblyExpressionContext
	AssemblyExpression(i int) IAssemblyExpressionContext
	AllAssemblyBlock() []IAssemblyBlockContext
	AssemblyBlock(i int) IAssemblyBlockContext

	// IsAssemblyForContext differentiates from other interfaces.
	IsAssemblyForContext()
}

type AssemblyForContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyForContext() *AssemblyForContext {
	var p = new(AssemblyForContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyFor
	return p
}

func (*AssemblyForContext) IsAssemblyForContext() {}

func NewAssemblyForContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyForContext {
	var p = new(AssemblyForContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyFor

	return p
}

func (s *AssemblyForContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyForContext) AllAssemblyExpression() []IAssemblyExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAssemblyExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssemblyExpressionContext); ok {
			tst[i] = t.(IAssemblyExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssemblyForContext) AssemblyExpression(i int) IAssemblyExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyForContext) AllAssemblyBlock() []IAssemblyBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			len++
		}
	}

	tst := make([]IAssemblyBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssemblyBlockContext); ok {
			tst[i] = t.(IAssemblyBlockContext)
			i++
		}
	}

	return tst
}

func (s *AssemblyForContext) AssemblyBlock(i int) IAssemblyBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *AssemblyForContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyForContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyForContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyFor(s)
	}
}

func (s *AssemblyForContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyFor(s)
	}
}

func (p *SolidityParser) AssemblyFor() (localctx IAssemblyForContext) {
	this := p
	_ = this

	localctx = NewAssemblyForContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SolidityParserRULE_assemblyFor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1087)
		p.Match(SolidityParserT__26)
	}
	p.SetState(1090)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__14:
		{
			p.SetState(1088)
			p.AssemblyBlock()
		}

	case SolidityParserT__13, SolidityParserT__24, SolidityParserT__43, SolidityParserT__49, SolidityParserT__58, SolidityParserT__61, SolidityParserT__65, SolidityParserT__94, SolidityParserBooleanLiteral, SolidityParserDecimalNumber, SolidityParserHexNumber, SolidityParserHexLiteralFragment, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier, SolidityParserStringLiteralFragment:
		{
			p.SetState(1089)
			p.AssemblyExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1092)
		p.AssemblyExpression()
	}
	p.SetState(1095)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__14:
		{
			p.SetState(1093)
			p.AssemblyBlock()
		}

	case SolidityParserT__13, SolidityParserT__24, SolidityParserT__43, SolidityParserT__49, SolidityParserT__58, SolidityParserT__61, SolidityParserT__65, SolidityParserT__94, SolidityParserBooleanLiteral, SolidityParserDecimalNumber, SolidityParserHexNumber, SolidityParserHexLiteralFragment, SolidityParserLeaveKeyword, SolidityParserPayableKeyword, SolidityParserConstructorKeyword, SolidityParserReceiveKeyword, SolidityParserIdentifier, SolidityParserStringLiteralFragment:
		{
			p.SetState(1094)
			p.AssemblyExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1097)
		p.AssemblyBlock()
	}

	return localctx
}

// IAssemblyIfContext is an interface to support dynamic dispatch.
type IAssemblyIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyExpression() IAssemblyExpressionContext
	AssemblyBlock() IAssemblyBlockContext

	// IsAssemblyIfContext differentiates from other interfaces.
	IsAssemblyIfContext()
}

type AssemblyIfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyIfContext() *AssemblyIfContext {
	var p = new(AssemblyIfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyIf
	return p
}

func (*AssemblyIfContext) IsAssemblyIfContext() {}

func NewAssemblyIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyIfContext {
	var p = new(AssemblyIfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyIf

	return p
}

func (s *AssemblyIfContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyIfContext) AssemblyExpression() IAssemblyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyIfContext) AssemblyBlock() IAssemblyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *AssemblyIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyIf(s)
	}
}

func (s *AssemblyIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyIf(s)
	}
}

func (p *SolidityParser) AssemblyIf() (localctx IAssemblyIfContext) {
	this := p
	_ = this

	localctx = NewAssemblyIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SolidityParserRULE_assemblyIf)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1099)
		p.Match(SolidityParserT__50)
	}
	{
		p.SetState(1100)
		p.AssemblyExpression()
	}
	{
		p.SetState(1101)
		p.AssemblyBlock()
	}

	return localctx
}

// IAssemblyLiteralContext is an interface to support dynamic dispatch.
type IAssemblyLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext
	DecimalNumber() antlr.TerminalNode
	HexNumber() antlr.TerminalNode
	HexLiteral() IHexLiteralContext
	BooleanLiteral() antlr.TerminalNode

	// IsAssemblyLiteralContext differentiates from other interfaces.
	IsAssemblyLiteralContext()
}

type AssemblyLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyLiteralContext() *AssemblyLiteralContext {
	var p = new(AssemblyLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyLiteral
	return p
}

func (*AssemblyLiteralContext) IsAssemblyLiteralContext() {}

func NewAssemblyLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyLiteralContext {
	var p = new(AssemblyLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyLiteral

	return p
}

func (s *AssemblyLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyLiteralContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AssemblyLiteralContext) DecimalNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserDecimalNumber, 0)
}

func (s *AssemblyLiteralContext) HexNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserHexNumber, 0)
}

func (s *AssemblyLiteralContext) HexLiteral() IHexLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexLiteralContext)
}

func (s *AssemblyLiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(SolidityParserBooleanLiteral, 0)
}

func (s *AssemblyLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyLiteral(s)
	}
}

func (s *AssemblyLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyLiteral(s)
	}
}

func (p *SolidityParser) AssemblyLiteral() (localctx IAssemblyLiteralContext) {
	this := p
	_ = this

	localctx = NewAssemblyLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SolidityParserRULE_assemblyLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1108)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserStringLiteralFragment:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1103)
			p.StringLiteral()
		}

	case SolidityParserDecimalNumber:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1104)
			p.Match(SolidityParserDecimalNumber)
		}

	case SolidityParserHexNumber:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1105)
			p.Match(SolidityParserHexNumber)
		}

	case SolidityParserHexLiteralFragment:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1106)
			p.HexLiteral()
		}

	case SolidityParserBooleanLiteral:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1107)
			p.Match(SolidityParserBooleanLiteral)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITupleExpressionContext is an interface to support dynamic dispatch.
type ITupleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsTupleExpressionContext differentiates from other interfaces.
	IsTupleExpressionContext()
}

type TupleExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleExpressionContext() *TupleExpressionContext {
	var p = new(TupleExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_tupleExpression
	return p
}

func (*TupleExpressionContext) IsTupleExpressionContext() {}

func NewTupleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleExpressionContext {
	var p = new(TupleExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_tupleExpression

	return p
}

func (s *TupleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TupleExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TupleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterTupleExpression(s)
	}
}

func (s *TupleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitTupleExpression(s)
	}
}

func (p *SolidityParser) TupleExpression() (localctx ITupleExpressionContext) {
	this := p
	_ = this

	localctx = NewTupleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, SolidityParserRULE_tupleExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1136)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__22:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1110)
			p.Match(SolidityParserT__22)
		}

		p.SetState(1112)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-6)) & ^0x3f) == 0 && ((int64(1)<<(_la-6))&-72038554396917503) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&524744174868627459) != 0) {
			{
				p.SetState(1111)
				p.expression(0)
			}

		}
		p.SetState(1120)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserT__15 {
			{
				p.SetState(1114)
				p.Match(SolidityParserT__15)
			}
			p.SetState(1116)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((int64((_la-6)) & ^0x3f) == 0 && ((int64(1)<<(_la-6))&-72038554396917503) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&524744174868627459) != 0) {
				{
					p.SetState(1115)
					p.expression(0)
				}

			}

			p.SetState(1122)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

		{
			p.SetState(1123)
			p.Match(SolidityParserT__23)
		}

	case SolidityParserT__41:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1124)
			p.Match(SolidityParserT__41)
		}
		p.SetState(1133)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-6)) & ^0x3f) == 0 && ((int64(1)<<(_la-6))&-72038554396917503) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&524744174868627459) != 0) {
			{
				p.SetState(1125)
				p.expression(0)
			}
			p.SetState(1130)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SolidityParserT__15 {
				{
					p.SetState(1126)
					p.Match(SolidityParserT__15)
				}
				{
					p.SetState(1127)
					p.expression(0)
				}

				p.SetState(1132)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1135)
			p.Match(SolidityParserT__42)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumberLiteralContext is an interface to support dynamic dispatch.
type INumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DecimalNumber() antlr.TerminalNode
	HexNumber() antlr.TerminalNode
	NumberUnit() antlr.TerminalNode

	// IsNumberLiteralContext differentiates from other interfaces.
	IsNumberLiteralContext()
}

type NumberLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberLiteralContext() *NumberLiteralContext {
	var p = new(NumberLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_numberLiteral
	return p
}

func (*NumberLiteralContext) IsNumberLiteralContext() {}

func NewNumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_numberLiteral

	return p
}

func (s *NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralContext) DecimalNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserDecimalNumber, 0)
}

func (s *NumberLiteralContext) HexNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserHexNumber, 0)
}

func (s *NumberLiteralContext) NumberUnit() antlr.TerminalNode {
	return s.GetToken(SolidityParserNumberUnit, 0)
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterNumberLiteral(s)
	}
}

func (s *NumberLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitNumberLiteral(s)
	}
}

func (p *SolidityParser) NumberLiteral() (localctx INumberLiteralContext) {
	this := p
	_ = this

	localctx = NewNumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, SolidityParserRULE_numberLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1138)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SolidityParserDecimalNumber || _la == SolidityParserHexNumber) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1140)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1139)
			p.Match(SolidityParserNumberUnit)
		}

	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReceiveKeyword() antlr.TerminalNode
	ConstructorKeyword() antlr.TerminalNode
	PayableKeyword() antlr.TerminalNode
	LeaveKeyword() antlr.TerminalNode
	Identifier() antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) ReceiveKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserReceiveKeyword, 0)
}

func (s *IdentifierContext) ConstructorKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserConstructorKeyword, 0)
}

func (s *IdentifierContext) PayableKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserPayableKeyword, 0)
}

func (s *IdentifierContext) LeaveKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserLeaveKeyword, 0)
}

func (s *IdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(SolidityParserIdentifier, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *SolidityParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, SolidityParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1142)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4612829510553845760) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&13963100161) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IHexLiteralContext is an interface to support dynamic dispatch.
type IHexLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllHexLiteralFragment() []antlr.TerminalNode
	HexLiteralFragment(i int) antlr.TerminalNode

	// IsHexLiteralContext differentiates from other interfaces.
	IsHexLiteralContext()
}

type HexLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexLiteralContext() *HexLiteralContext {
	var p = new(HexLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_hexLiteral
	return p
}

func (*HexLiteralContext) IsHexLiteralContext() {}

func NewHexLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexLiteralContext {
	var p = new(HexLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_hexLiteral

	return p
}

func (s *HexLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *HexLiteralContext) AllHexLiteralFragment() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserHexLiteralFragment)
}

func (s *HexLiteralContext) HexLiteralFragment(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserHexLiteralFragment, i)
}

func (s *HexLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterHexLiteral(s)
	}
}

func (s *HexLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitHexLiteral(s)
	}
}

func (p *SolidityParser) HexLiteral() (localctx IHexLiteralContext) {
	this := p
	_ = this

	localctx = NewHexLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, SolidityParserRULE_hexLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1145)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1144)
				p.Match(SolidityParserHexLiteralFragment)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1147)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext())
	}

	return localctx
}

// IOverrideSpecifierContext is an interface to support dynamic dispatch.
type IOverrideSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUserDefinedTypeName() []IUserDefinedTypeNameContext
	UserDefinedTypeName(i int) IUserDefinedTypeNameContext

	// IsOverrideSpecifierContext differentiates from other interfaces.
	IsOverrideSpecifierContext()
}

type OverrideSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOverrideSpecifierContext() *OverrideSpecifierContext {
	var p = new(OverrideSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_overrideSpecifier
	return p
}

func (*OverrideSpecifierContext) IsOverrideSpecifierContext() {}

func NewOverrideSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverrideSpecifierContext {
	var p = new(OverrideSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_overrideSpecifier

	return p
}

func (s *OverrideSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *OverrideSpecifierContext) AllUserDefinedTypeName() []IUserDefinedTypeNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			len++
		}
	}

	tst := make([]IUserDefinedTypeNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserDefinedTypeNameContext); ok {
			tst[i] = t.(IUserDefinedTypeNameContext)
			i++
		}
	}

	return tst
}

func (s *OverrideSpecifierContext) UserDefinedTypeName(i int) IUserDefinedTypeNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedTypeNameContext)
}

func (s *OverrideSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverrideSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverrideSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterOverrideSpecifier(s)
	}
}

func (s *OverrideSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitOverrideSpecifier(s)
	}
}

func (p *SolidityParser) OverrideSpecifier() (localctx IOverrideSpecifierContext) {
	this := p
	_ = this

	localctx = NewOverrideSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, SolidityParserRULE_overrideSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1149)
		p.Match(SolidityParserT__95)
	}
	p.SetState(1161)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserT__22 {
		{
			p.SetState(1150)
			p.Match(SolidityParserT__22)
		}
		{
			p.SetState(1151)
			p.UserDefinedTypeName()
		}
		p.SetState(1156)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserT__15 {
			{
				p.SetState(1152)
				p.Match(SolidityParserT__15)
			}
			{
				p.SetState(1153)
				p.UserDefinedTypeName()
			}

			p.SetState(1158)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1159)
			p.Match(SolidityParserT__23)
		}

	}

	return localctx
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStringLiteralFragment() []antlr.TerminalNode
	StringLiteralFragment(i int) antlr.TerminalNode

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) AllStringLiteralFragment() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserStringLiteralFragment)
}

func (s *StringLiteralContext) StringLiteralFragment(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserStringLiteralFragment, i)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *SolidityParser) StringLiteral() (localctx IStringLiteralContext) {
	this := p
	_ = this

	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, SolidityParserRULE_stringLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1164)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1163)
				p.Match(SolidityParserStringLiteralFragment)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1166)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext())
	}

	return localctx
}

func (p *SolidityParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 38:
		var t *TypeNameContext = nil
		if localctx != nil {
			t = localctx.(*TypeNameContext)
		}
		return p.TypeName_Sempred(t, predIndex)

	case 70:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SolidityParser) TypeName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SolidityParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 27)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 25)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 24)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 21)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
